<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bluesky Account Production Analysis</title>
  <style>
    body { font-family: sans-serif; margin: 1rem; }
    pre { background: #f8f8f8; padding: 1rem; border: 1px solid #ccc; }
  </style>
</head>
<body>
  <h1>Bluesky Account Production Analysis</h1>
  <pre id="output"></pre>

  <script>
  /***********************************************************************
   * Global settings and basic caching
   ***********************************************************************/
  const did = "did:plc:gq4fo3u6tqzzdkjlwzpb23tj";
  const handle = "dame.bsky.social";
  const serviceEndpoint = "https://enoki.us-east.host.bsky.network";
  const plcDirectoryEndpoint = "https://plc.directory";
  const publicServiceEndpoint = "https://public.api.bsky.app";

  // Basic in-memory cache to avoid duplicate API calls.
  const cache = {};

  /***********************************************************************
   * Helper Functions
   ***********************************************************************/

  // Standard fetch with error checking.
  async function getJSON(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} error for ${url}`);
      }
      return await response.json();
    } catch (err) {
      console.error("Error in getJSON for", url, err);
      throw err;
    }
  }

  // Cached fetch: if we already have data for a URL, return it.
  async function cachedGetJSON(url) {
    if (cache[url]) return cache[url];
    const data = await getJSON(url);
    cache[url] = data;
    return data;
  }

  /***********************************************************************
   * Endpoint calls with pagination and caching
   ***********************************************************************/
  // 1. Fetch Profile data
  async function fetchProfile() {
    const url = `${publicServiceEndpoint}/xrpc/app.bsky.actor.getProfile?actor=${encodeURIComponent(did)}`;
    return await cachedGetJSON(url);
  }

  // 2. Fetch all blobs (pagination using cursor)
  async function fetchAllBlobsCount() {
    let urlBase = `${serviceEndpoint}/xrpc/com.atproto.sync.listBlobs?did=${encodeURIComponent(did)}&limit=1000`;
    let count = 0, cursor = null;
    do {
      const url = urlBase + (cursor ? `&cursor=${cursor}` : '');
      const data = await cachedGetJSON(url);
      count += Array.isArray(data.blobs) ? data.blobs.length : 0;
      cursor = data.cursor || null;
    } while (cursor);
    return count;
  }

  // 3. Fetch repo description (which includes a list of collections)
  async function fetchRepoDescription() {
    const url = `${serviceEndpoint}/xrpc/com.atproto.repo.describeRepo?repo=${encodeURIComponent(did)}`;
    return await cachedGetJSON(url);
  }

  // 4. Fetch records from a given collection (pagination using cursor)
  async function fetchRecordsForCollection(collectionName) {
    let urlBase = `${serviceEndpoint}/xrpc/com.atproto.repo.listRecords?repo=${encodeURIComponent(did)}&collection=${encodeURIComponent(collectionName)}&limit=100`;
    let records = [];
    let cursor = null;
    do {
      const url = urlBase + (cursor ? `&cursor=${cursor}` : '');
      const data = await cachedGetJSON(url);
      if (Array.isArray(data.records)) {
        records = records.concat(data.records);
      }
      cursor = data.cursor || null;
    } while (cursor);
    return records;
  }

  // 5. Fetch audit log from PLC Directory
  async function fetchAuditLog() {
    const url = `${plcDirectoryEndpoint}/${encodeURIComponent(did)}/log/audit`;
    return await cachedGetJSON(url);
  }

  // 6. Fetch Author Feed (for engagements)
  async function fetchAuthorFeed() {
    let urlBase = `${publicServiceEndpoint}/xrpc/app.bsky.feed.getAuthorFeed?actor=${encodeURIComponent(did)}&limit=100`;
    let feed = [];
    let cursor = null;
    do {
      const url = urlBase + (cursor ? `&cursor=${cursor}` : '');
      const data = await cachedGetJSON(url);
      if (Array.isArray(data.feed)) {
        feed = feed.concat(data.feed);
      }
      cursor = data.cursor || null;
    } while (cursor);
    return feed;
  }

  /***********************************************************************
   * Calculation Functions
   ***********************************************************************/
  // Calculate age in days and age percentage (based on reference date)
  function calculateAge(createdAt) {
    const created = new Date(createdAt);
    const today = new Date();
    const diffTime = Math.abs(today - created);
    const ageInDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    // Reference date: 2022-11-17T00:35:16.391Z
    const refDate = new Date("2022-11-17T00:35:16.391Z");
    const daysSinceRef = Math.floor(Math.abs(today - refDate) / (1000 * 60 * 60 * 24));
    const agePercentage = daysSinceRef > 0 ? ageInDays / daysSinceRef : 0;
    return { ageInDays, agePercentage };
  }

  // Calculate posting style using the provided criteria.
  // Expects an object with posts stats.
  function calculatePostingStyle(stats) {
    const {
      onlyPostsPerDay = 0,
      replyOtherPercentage = 0,
      textPercentage = 0,
      imagePercentage = 0,
      videoPercentage = 0,
      linkPercentage = 0,
      altTextPercentage = 0,
      postsPerDay = 0
    } = stats;

    // Rule: if not enough post frequency then maybe Lurker.
    if (postsPerDay < 0.1 && stats.totalBskyRecordsPerDay > 0.3) {
      return "Lurker";
    }

    if (onlyPostsPerDay > 0.8 && replyOtherPercentage >= 0.3) {
      if (textPercentage > linkPercentage && textPercentage > imagePercentage && textPercentage > videoPercentage) {
        return "Engaged Text Poster";
      }
      if (imagePercentage > linkPercentage && imagePercentage > textPercentage && imagePercentage > videoPercentage) {
        return (altTextPercentage <= 0.3) ? "Engaged Image Poster who's bad at alt text" : "Engaged Image Poster";
      }
      if (linkPercentage > imagePercentage && linkPercentage > textPercentage && linkPercentage > videoPercentage) {
        return "Engaged Link Poster";
      }
      if (videoPercentage > imagePercentage && videoPercentage > textPercentage && videoPercentage > linkPercentage) {
        return "Engaged Video Poster";
      }
      return "Engaged Poster";
    } else if (onlyPostsPerDay > 0.8 && replyOtherPercentage < 0.3) {
      if (textPercentage > linkPercentage && textPercentage > imagePercentage && textPercentage > videoPercentage) {
        return "Unengaged Text Poster";
      }
      if (imagePercentage > linkPercentage && imagePercentage > textPercentage && imagePercentage > videoPercentage) {
        return (altTextPercentage <= 0.3) ? "Unengaged Image Poster who's bad at alt text" : "Unengaged Image Poster";
      }
      if (linkPercentage > imagePercentage && linkPercentage > textPercentage && linkPercentage > videoPercentage) {
        return "Unengaged Link Poster";
      }
      if (videoPercentage > imagePercentage && videoPercentage > textPercentage && videoPercentage > linkPercentage) {
        return "Unengaged Video Poster";
      }
      return "Unengaged Poster";
    }
    if (replyOtherPercentage >= 0.5) return "Reply Guy";
    if (stats.quoteOtherPercentage >= 0.5) return "Quote Guy";
    if (stats.repostOtherPercentage >= 0.5) return "Repost Guy";

    return "Unknown";
  }

  // Calculate social status (one label)
  function calculateSocialStatus({ ageInDays, followersCount, followsCount }) {
    const followPercentage = followersCount > 0 ? followsCount / followersCount : 0;
    if (ageInDays < 30) return "Newbie";
    if (followPercentage < 0.5) {
      if (followersCount >= 500 && followersCount < 10000) return "Micro Influencer";
      if (followersCount >= 10000 && followersCount < 100000) return "Influencer";
      if (followersCount >= 100000) return "Celebrity";
    }
    return "Community Member";
  }

  // Calculate activity status given rate (records per day)
  function calculateActivityStatus(rate) {
    if (rate === 0) return "inactive";
    if (rate > 0 && rate < 1) return "eepy";
    if (rate >= 1 && rate < 10) return "awake";
    if (rate >= 10) return "wired";
  }

  // Calculate profile completion: complete/incomplete/not started.
  function calculateProfileCompletion(profile) {
    const hasDisplayName = Boolean(profile.displayName && profile.displayName.trim());
    const hasBanner = Boolean(profile.banner && profile.banner.trim());
    const hasDescription = Boolean(profile.description && profile.description.trim());
    if (hasDisplayName && hasBanner && hasDescription) return "complete";
    if (hasDisplayName || hasBanner || hasDescription) return "incomplete";
    return "not started";
  }

  // Calculate domain rarity based on handle and domain length.
  function calculateDomainRarity(handle) {
    const parts = handle.split(".");
    // Assume domain is the part after the first dot.
    let domain = parts.slice(1).join("."); 
    if (handle.includes("bsky.social")) {
      const len = domain.length;
      if (len >= 21) return "very common";
      if (len >= 18 && len <= 20) return "common";
      if (len === 17) return "uncommon";
      if (len === 16) return "rare";
      if (len === 15) return "very rare";
      if (len <= 14) return "extremely rare";
    } else {
      let len = domain.length;
      const hasStandardTLD = [".com", ".net", ".org"].some(tld => domain.includes(tld));
      if (hasStandardTLD) {
        if (len >= 15) return "very common";
        if (len >= 12 && len <= 14) return "common";
        if (len >= 9 && len <= 11) return "uncommon";
        if (len >= 7 && len <= 8) return "rare";
        if (len === 6) return "very rare";
        if (len <= 5) return "extremely rare";
      } else {
        if (len >= 14) return "very common";
        if (len >= 11 && len <= 13) return "common";
        if (len >= 8 && len <= 10) return "uncommon";
        if (len >= 6 && len <= 7) return "rare";
        if (len === 5) return "very rare";
        if (len <= 4) return "extremely rare";
      }
    }
    return "unknown";
  }

  // Calculate era based on createdAt date.
  function calculateEra(createdAt) {
    const created = new Date(createdAt);
    if (created >= new Date("2022-11-16") && created <= new Date("2023-01-31")) {
      return "pre-history";
    } else if (created >= new Date("2023-02-01") && created <= new Date("2024-01-31")) {
      return "invite-only";
    } else if (created > new Date("2024-01-31")) {
      return "public-release";
    }
    return "unknown";
  }

  // Calculate aggregate records for the account by iterating over each collection.
  async function calculateRecordsAggregate(collectionNames) {
    let totalRecords = 0;
    let totalBskyRecords = 0;
    let totalNonBskyRecords = 0;
    for (const col of collectionNames) {
      const recs = await fetchRecordsForCollection(col);
      totalRecords += recs.length;
      if (col.indexOf("app.bsky") !== -1) {
        totalBskyRecords += recs.length;
      } else {
        totalNonBskyRecords += recs.length;
      }
    }
    return { totalRecords, totalBskyRecords, totalNonBskyRecords };
  }

  // Calculate engagements for the account using the author feed.
  async function calculateEngagements() {
    const feed = await fetchAuthorFeed();
    let likesReceived = 0, repostsReceived = 0, quotesReceived = 0, repliesReceived = 0;
    for (const item of feed) {
      // Filter out posts that include the string "#reasonRepost"
      if (item && item.record && JSON.stringify(item.record).indexOf("#reasonRepost") !== -1) {
        continue;
      }
      likesReceived += (item.likeCount || 0);
      repostsReceived += (item.repostCount || 0);
      quotesReceived += (item.quoteCount || 0);
      repliesReceived += (item.replyCount || 0);
    }
    // For unique engagers and top engagers, you could combine calls to endpoints:
    // app.bsky.feed.getLikes, app.bsky.feed.getPostThread, app.bsky.feed.getRepostedBy.
    // For now we return sample values.
    return {
      likesReceived,
      repostsReceived,
      quotesReceived,
      repliesReceived,
      uniqueEngagers300Posts: 0,
      topEngagers300posts: [],
      topLiker300posts: [],
      topReposter300posts: [],
      topQuoter300posts: [],
      topReplier300posts: []
    };
  }

  // Build the analysis narrative paragraphs based on the criteria.
  function buildAnalysisNarrative(accountData) {
    const { profile, activityAll, alsoKnownAs } = accountData;
    const { ageInDays, agePercentage } = calculateAge(profile.createdAt);
    // Calculate account age statement:
    let accountAgeStatement = "";
    if (agePercentage >= 0.97) {
      accountAgeStatement = "since the very beginning and is";
    } else if (agePercentage >= 0.7) {
      accountAgeStatement = "for a very long time and is";
    } else if (agePercentage >= 0.5) {
      accountAgeStatement = "for a long time and is";
    } else if (agePercentage >= 0.1) {
      accountAgeStatement = "for awhile and is";
    } else if (agePercentage >= 0.02) {
      accountAgeStatement = "for only a short period of time and is";
    } else {
      accountAgeStatement = "for barely any time at all";
    }
    // bluesky features:
    const totalBskyCollections = activityAll.totalBskyCollections || 0;
    let blueskyFeatures = "";
    if (totalBskyCollections >= 12) {
      blueskyFeatures = "they are using all of Bluesky's core features";
    } else if (totalBskyCollections >= 8) {
      blueskyFeatures = "they are using most of Bluesky’s core features";
    } else if (totalBskyCollections >= 3) {
      blueskyFeatures = "they are using some of Bluesky’s core features";
    } else {
      blueskyFeatures = "they haven't used any of Bluesky's core features yet";
    }
    // atproto engagement:
    const totalNonBskyCollections = activityAll.totalNonBskyCollections || 0;
    const totalNonBskyRecords = activityAll.totalNonBskyRecords || 0;
    let atprotoEngagement = "";
    if (totalNonBskyCollections >= 10 && totalNonBskyRecords > 100) {
      atprotoEngagement = "is extremely engaged, having used many different services or tools";
    } else if (totalNonBskyCollections >= 5 && totalNonBskyRecords > 50) {
      atprotoEngagement = "is very engaged, having used many different services or tools";
    } else if (totalNonBskyCollections > 0 && totalNonBskyRecords > 5) {
      atprotoEngagement = "has dipped their toes in the water, but has yet to go deeper";
    } else {
      atprotoEngagement = "has not yet explored what's out there";
    }
    // Domain history:
    let domainHistoryStatement = "";
    if (alsoKnownAs.totalCustomAkas > 0 && profile.handle.includes("bsky.social")) {
      domainHistoryStatement = "They've used a custom domain name at some point but are currently using a default Bluesky handle";
    } else if (!profile.handle.includes("bsky.social")) {
      domainHistoryStatement = "They currently are using a custom domain";
    } else if (alsoKnownAs.totalAkas > 2 && !profile.handle.includes("bsky.social")) {
      domainHistoryStatement = "They have a custom domain set and have a history of using different aliases";
    } else {
      domainHistoryStatement = "They still have a default Bluesky handle";
    }
    // Rotation key statement:
    let rotationKeyStatement = (accountData.rotationKeys === 2)
      ? "They don't have their own rotation key set"
      : "They have their own rotation key set";
    // PDS Host Statement:
    let pdsHostStatement = serviceEndpoint.includes("bsky.network")
      ? "their PDS is hosted by a Bluesky mushroom"
      : "their PDS is hosted by either a third-party or themselves";

    // Paragraph 1 Narrative
    const narrative1 = `${profile.displayName} has been on the network ${accountAgeStatement} ${calculateActivityStatus(activityAll.totalRecordsPerDay)}. ` +
      `Their profile is ${calculateProfileCompletion(profile)}, and ${blueskyFeatures}. ` +
      `When it comes to the broader AT Proto ecosystem, this identity ${atprotoEngagement}. ` +
      `${domainHistoryStatement} which is ${calculateDomainRarity(profile.handle)}. ` +
      `${rotationKeyStatement}, and ${pdsHostStatement}.`;

    // Paragraph 2 Narrative
    const era = calculateEra(profile.createdAt);
    const postingStyle = accountData.postingStyle; // computed already
    const socialStatus = accountData.socialStatus;  // computed already
    // You might compute mediaType by examining posting breakdown; here we use a sample placeholder.
    const mediaType = "a mix of text, images, and video";
    const followRatio = profile.followersCount > 0 
      ? (profile.followsCount / profile.followersCount).toFixed(2) 
      : 0;
    const narrative2 = `${profile.displayName} first joined Bluesky during the ${era} era. ` +
      `Their style of posting is "${postingStyle}". ` +
      `Their posts consist of ${mediaType}. ` +
      `They are ${socialStatus} as is indicated by their follower count of ${profile.followersCount} and their follower/following ratio of ${followRatio}.`;

    return narrative1 + "\n\n" + narrative2;
  }

  /***********************************************************************
   * Main Function – Build accountData and final JSON object.
   ***********************************************************************/
  async function loadAccountData() {
    try {
      // 1. Get basic profile (and use it for several fields)
      const profile = await fetchProfile();

      // 2. Age details
      const { ageInDays, agePercentage } = calculateAge(profile.createdAt);

      // 3. Blobs count and per-day/post calculations
      const blobsCount = await fetchAllBlobsCount();

      // 4. Repo description gives collections.
      const repoDescription = await fetchRepoDescription();
      // Assume the repo description contains an array 'collections'
      let collections = repoDescription.collections || [];
      const totalCollections = collections.length;
      // Total app.bsky collections:
      const bskyCollectionNames = collections.filter(col => col.indexOf("app.bsky") !== -1);
      const totalBskyCollections = bskyCollectionNames.length;
      const totalNonBskyCollections = totalCollections - totalBskyCollections;
      
      // 5. For per-record data, build an array of collections you want to iterate.
      // The following collections are expected per your JSON structure:
      const targetCollections = [
        "app.bsky.feed.post",
        "app.bsky.feed.repost",
        "app.bsky.feed.like",
        "app.bsky.graph.block",
        "app.bsky.feed.generator",
        "app.bsky.graph.follow",
        "app.bsky.graph.list",
        "app.bsky.graph.listblock",
        "app.bsky.graph.listitem",
        "app.bsky.graph.starterpack"
      ];
      // Also add non-app.bsky collections by filtering the repo collections list:
      collections.forEach(col => {
        if (col.indexOf("app.bsky") === -1 && targetCollections.indexOf(col) === -1) {
          targetCollections.push(col);
        }
      });

      // 6. Compute aggregate record counts for the repo across all collections.
      const { totalRecords, totalBskyRecords, totalNonBskyRecords } = await calculateRecordsAggregate(targetCollections);
      const totalRecordsPerDay = ageInDays ? totalRecords / ageInDays : 0;
      const totalBskyRecordsPerDay = ageInDays ? totalBskyRecords / ageInDays : 0;
      const totalNonBskyRecordsPerDay = ageInDays ? totalNonBskyRecords / ageInDays : 0;
      const totalBskyRecordsPercentage = totalRecords ? totalBskyRecords / totalRecords : 0;
      const totalNonBskyRecordsPercentage = totalRecords ? totalNonBskyRecords / totalRecords : 0;

      // 7. For detailed post statistics, fetch posts for "app.bsky.feed.post" and then filter by conditions.
      const postsRecords = await fetchRecordsForCollection("app.bsky.feed.post");
      const postsCount = profile.postsCount || postsRecords.length;
      // Helper functions to do filtering:
      function filterRecords(records, testFunc) {
        return records.filter(testFunc).length;
      }
      // Count only posts (records with no "reply" key)
      const onlyPosts = filterRecords(postsRecords, rec => !rec.reply);
      const onlyPostsPerDay = ageInDays ? onlyPosts / ageInDays : 0;
      // Count replies – check existence of reply key.
      const onlyReplies = filterRecords(postsRecords, rec => !!rec.reply);
      const onlyRepliesPerDay = ageInDays ? onlyReplies / ageInDays : 0;
      // Replies to self: reply records where "parent" or "root" contains the did.
      const onlyRepliesToSelf = filterRecords(postsRecords, rec => {
        if (!rec.reply) return false;
        const author = rec.reply.author || "";
        return author.indexOf(did) !== -1;
      });
      const onlyRepliesToSelfPerDay = ageInDays ? onlyRepliesToSelf / ageInDays : 0;
      // Replies to others: reply records where parent/root do not contain the did.
      const onlyRepliesToOthers = onlyReplies - onlyRepliesToSelf;
      const onlyRepliesToOthersPerDay = ageInDays ? onlyRepliesToOthers / ageInDays : 0;
      // Count quotes: records with embed object and $type "app.bsky.embed.record"
      const onlyQuotes = filterRecords(postsRecords, rec => rec.embed && rec.embed["$type"] === "app.bsky.embed.record");
      const onlyQuotesPerDay = ageInDays ? onlyQuotes / ageInDays : 0;
      // Self quotes: embed record with URI containing the did.
      const onlySelfQuotes = filterRecords(postsRecords, rec => rec.embed && rec.embed["$type"] === "app.bsky.embed.record" && (rec.embed.URI || "").indexOf(did) !== -1);
      const onlySelfQuotesPerDay = ageInDays ? onlySelfQuotes / ageInDays : 0;
      // Other quotes:
      const onlyOtherQuotes = onlyQuotes - onlySelfQuotes;
      const onlyOtherQuotesPerDay = ageInDays ? onlyOtherQuotes / ageInDays : 0;
      // Count reposts from "app.bsky.feed.repost"
      const repostRecords = await fetchRecordsForCollection("app.bsky.feed.repost");
      const onlyReposts = repostRecords.length;
      const onlyRepostsPerDay = ageInDays ? onlyReposts / ageInDays : 0;
      // Self reposts: subject.URI includes did
      const onlySelfReposts = filterRecords(repostRecords, rec => (rec.subject && rec.subject.URI || "").indexOf(did) !== -1);
      const onlySelfRepostsPerDay = ageInDays ? onlySelfReposts / ageInDays : 0;
      const onlyOtherReposts = onlyReposts - onlySelfReposts;
      const onlyOtherRepostsPerDay = ageInDays ? onlyOtherReposts / ageInDays : 0;
      // Count posts with images: embed key with $type "app.bsky.embed.images"
      const postsWithImages = filterRecords(postsRecords, rec => rec.embed && rec.embed["$type"] === "app.bsky.embed.images");
      const imagePostsPerDay = ageInDays ? postsWithImages / ageInDays : 0;
      // Among image posts, count those with alt text
      const imagePostsAltText = filterRecords(postsRecords, rec => rec.embed && rec.embed["$type"] === "app.bsky.embed.images" && rec.embed.alt && rec.embed.alt.trim());
      // Without alt text:
      const imagePostsNoAltText = postsWithImages - imagePostsAltText;
      const altTextPercentage = postsWithImages ? imagePostsAltText / postsWithImages : 0;
      // Count posts with only text: no embed, no reply, no richtext links.
      const postsWithOnlyText = filterRecords(postsRecords, rec =>
        !rec.embed && !rec.reply && !(rec.facets && JSON.stringify(rec.facets).indexOf("app.bsky.richtext.facet#link") !== -1)
      );
      const textPostsPerDay = ageInDays ? postsWithOnlyText / ageInDays : 0;
      // Count posts with mentions: facets where one of the features is "app.bsky.richtext.facet#mention"
      const postsWithMentions = filterRecords(postsRecords, rec =>
        rec.facets && rec.facets.features && rec.facets.features.some(f => f["$type"] === "app.bsky.richtext.facet#mention")
      );
      const mentionPostsPerDay = ageInDays ? postsWithMentions / ageInDays : 0;
      // Count posts with video: embed key with $type "app.bsky.embed.video"
      const postsWithVideo = filterRecords(postsRecords, rec => rec.embed && rec.embed["$type"] === "app.bsky.embed.video");
      const videoPostsPerDay = ageInDays ? postsWithVideo / ageInDays : 0;
      // Count posts with links: either facets with app.bsky.richtext.facet#link OR embed external with $type "app.bsky.embed.external"
      const postsWithLinks = filterRecords(postsRecords, rec => {
        if (rec.facets && rec.facets.features && rec.facets.features.some(f => f["$type"] === "app.bsky.richtext.facet#link")) return true;
        if (rec.embed && rec.embed["$type"] === "app.bsky.embed.external") return true;
        return false;
      });
      const linkPostsPerDay = ageInDays ? postsWithLinks / ageInDays : 0;

      // Prepare a stats object for posting style calculation:
      const postStats = {
        postsCount,
        postsPerDay: ageInDays ? postsCount / ageInDays : 0,
        onlyPosts,
        onlyPostsPerDay,
        onlyReplies,
        onlyRepliesPerDay,
        onlyRepliesToSelf,
        onlyRepliesToSelfPerDay,
        onlyRepliesToOthers,
        onlyRepliesToOthersPerDay,
        onlyQuotes,
        onlyQuotesPerDay,
        onlySelfQuotes,
        onlySelfQuotesPerDay,
        onlyOtherQuotes,
        onlyOtherQuotesPerDay,
        onlyReposts,
        onlyRepostsPerDay,
        onlySelfReposts,
        onlySelfRepostsPerDay,
        onlyOtherReposts,
        onlyOtherRepostsPerDay,
        postsWithImages,
        imagePostsPerDay,
        postsWithOnlyText,
        textPostsPerDay,
        postsWithMentions,
        mentionPostsPerDay,
        postsWithVideo,
        videoPostsPerDay,
        postsWithLinks,
        linkPostsPerDay,
        imagePostsAltText,
        imagePostsNoAltText,
        altTextPercentage,
        // You may wish to compute replyPercentage etc. using your desired formula.
        replyPercentage: postsCount ? onlyReplies / postsCount : 0,
        replySelfPercentage: postsCount ? onlyRepliesToSelf / postsCount : 0,
        replyOtherPercentage: postsCount ? onlyRepliesToOthers / postsCount : 0,
        quotePercentage: postsCount ? onlyQuotes / postsCount : 0,
        quoteSelfPercentage: postsCount ? onlySelfQuotes / postsCount : 0,
        quoteOtherPercentage: postsCount ? onlyOtherQuotes / postsCount : 0,
        repostPercentage: postsCount ? onlyReposts / postsCount : 0,
        repostSelfPercentage: postsCount ? onlySelfReposts / postsCount : 0,
        repostOtherPercentage: postsCount ? onlyOtherReposts / postsCount : 0,
        textPercentage: postsCount ? postsWithOnlyText / postsCount : 0,
        linkPercentage: postsCount ? postsWithLinks / postsCount : 0,
        imagePercentage: postsCount ? postsWithImages / postsCount : 0,
        videoPercentage: postsCount ? postsWithVideo / postsCount : 0,
        totalBskyRecordsPerDay,
        totalNonBskyRecordsPerDay,
      };

      // 8. Fetch audit log for rotation key and alsoKnownAs info.
      const auditLogData = await fetchAuditLog();
      let rotationKeys = 0;
      let akaSet = new Set();
      let totalAkas = 0, totalCustomAkas = 0, totalBskyAkas = 0;
      if (auditLogData && Array.isArray(auditLogData.records)) {
        // Pick the latest record for active alias count.
        auditLogData.records.forEach(record => {
          if (record.rotation && Array.isArray(record.rotation.keys)) {
            rotationKeys = Math.max(rotationKeys, record.rotation.keys.length);
          }
          if (record.alsoKnownAs && Array.isArray(record.alsoKnownAs)) {
            record.alsoKnownAs.forEach(alias => {
              akaSet.add(alias);
              totalAkas++;
              if (alias.indexOf("bsky.social") !== -1) {
                totalBskyAkas++;
              } else {
                totalCustomAkas++;
              }
            });
          }
        });
      }

      // 9. Compute engagements from author feed.
      const engagementsReceived = await calculateEngagements();

      // 10. Compute overall activity statuses.
      const overallActivityStatus = calculateActivityStatus(totalRecordsPerDay);
      const bskyActivityStatus = calculateActivityStatus(totalBskyRecordsPerDay);
      const atprotoActivityStatus = calculateActivityStatus(totalNonBskyRecordsPerDay);

      // 11. Compute posting style.
      const postingStyle = calculatePostingStyle({
        ...postStats,
        totalBskyRecordsPerDay
      });

      // 12. Compute social status.
      const socialStatus = calculateSocialStatus({
        ageInDays,
        followersCount: profile.followersCount || 0,
        followsCount: profile.followsCount || 0
      });

      // 13. Build analysis narrative paragraphs.
      const narrative = buildAnalysisNarrative({
        profile,
        activityAll: {
          totalRecords: totalRecords,
          totalRecordsPerDay: totalRecordsPerDay,
          totalBskyCollections,
          totalNonBskyCollections,
          totalBskyRecords,
          totalBskyRecordsPerDay,
          totalBskyRecordsPercentage,
          totalNonBskyRecords,
          totalNonBskyRecordsPerDay,
          totalNonBskyRecordsPercentage,
        },
        postingStyle,
        socialStatus,
        alsoKnownAs: {
          totalAkas,
          totalCustomAkas,
          totalBskyAkas
        }
      });

      // 14. Construct final accountData JSON.
      const accountData = {
        profile: {
          ...profile,
          did: profile.did || did // Ensure did is present.
        },
        displayName: profile.displayName,
        handle: profile.handle,
        did: profile.did || did,
        profileEditedDate: profile.indexedAt,
        profileCompletion: calculateProfileCompletion(profile),
        scoreGeneratedAt: new Date().toISOString(),
        serviceEndpoint,
        pdsType: serviceEndpoint.includes("bsky.network") ? "Bluesky" : "Third-party",
        createdAt: profile.createdAt,
        ageInDays,
        agePercentage,
        blobsCount,
        blobsPerDay: ageInDays ? blobsCount / ageInDays : 0,
        blobsPerPost: postsCount ? blobsCount / postsCount : 0,
        blobsPerImagePost: postsWithImages ? blobsCount / postsWithImages : 0,
        followersCount: profile.followersCount,
        followsCount: profile.followsCount,
        followPercentage: profile.followersCount ? profile.followsCount / profile.followersCount : 0,
        postsCount,
        rotationKeys,
        era: calculateEra(profile.createdAt),
        postingStyle,
        socialStatus,
        activityAll: {
          activityStatus: overallActivityStatus,
          bskyActivityStatus,
          atprotoActivityStatus,
          totalCollections,
          totalBskyCollections,
          totalNonBskyCollections,
          totalRecords,
          totalRecordsPerDay,
          totalBskyRecords,
          totalBskyRecordsPerDay,
          totalBskyRecordsPercentage,
          totalNonBskyRecords,
          totalNonBskyRecordsPerDay,
          totalNonBskyRecordsPercentage,
          plcOperations: (auditLogData && auditLogData.records) ? auditLogData.records.length : 0,
          "app.bsky.feed.post": {
            postsCount,
            postsPerDay: ageInDays ? postsCount / ageInDays : 0,
            onlyPosts,
            onlyPostsPerDay,
            onlyReplies,
            onlyRepliesPerDay,
            onlyRepliesToSelf,
            onlyRepliesToSelfPerDay,
            onlyRepliesToOthers,
            onlyRepliesToOthersPerDay,
            onlyQuotes,
            onlyQuotesPerDay,
            onlySelfQuotes,
            onlySelfQuotesPerDay,
            onlyOtherQuotes,
            onlyOtherQuotesPerDay,
            onlyReposts,
            onlyRepostsPerDay,
            onlySelfReposts,
            onlySelfRepostsPerDay,
            onlyOtherReposts,
            onlyOtherRepostsPerDay,
            postsWithImages,
            imagePostsPerDay,
            postsWithOnlyText,
            textPostsPerDay,
            postsWithMentions,
            mentionPostsPerDay,
            postsWithVideo,
            videoPostsPerDay,
            postsWithLinks,
            linkPostsPerDay,
            imagePostsAltText,
            imagePostsNoAltText,
            altTextPercentage,
            replyPercentage: postsCount ? onlyReplies / postsCount : 0,
            replySelfPercentage: postsCount ? onlyRepliesToSelf / postsCount : 0,
            replyOtherPercentage: postsCount ? onlyRepliesToOthers / postsCount : 0,
            quotePercentage: postsCount ? onlyQuotes / postsCount : 0,
            quoteSelfPercentage: postsCount ? onlySelfQuotes / postsCount : 0,
            quoteOtherPercentage: postsCount ? onlyOtherQuotes / postsCount : 0,
            repostPercentage: postsCount ? onlyReposts / postsCount : 0,
            repostSelfPercentage: postsCount ? onlySelfReposts / postsCount : 0,
            repostOtherPercentage: postsCount ? onlyOtherReposts / postsCount : 0,
            textPercentage: postsCount ? postsWithOnlyText / postsCount : 0,
            linkPercentage: postsCount ? postsWithLinks / postsCount : 0,
            imagePercentage: postsCount ? postsWithImages / postsCount : 0,
            videoPercentage: postsCount ? postsWithVideo / postsCount : 0
          },
          "app.bsky.feed.threadgate": (await fetchRecordsForCollection("app.bsky.feed.threadgate")).length || 0,
          "app.bsky.feed.like": {
            likes: (await fetchRecordsForCollection("app.bsky.feed.like")).length || 0,
            likesPerDay: ageInDays ? ((await fetchRecordsForCollection("app.bsky.feed.like")).length) / ageInDays : 0
          },
          "app.bsky.graph.block": {
            blocks: (await fetchRecordsForCollection("app.bsky.graph.block")).length || 0,
            blocksPerDay: ageInDays ? ((await fetchRecordsForCollection("app.bsky.graph.block")).length) / ageInDays : 0
          },
          "app.bsky.feed.generator": (await fetchRecordsForCollection("app.bsky.feed.generator")).length || 0,
          "app.bsky.graph.follow": {
            follows: (await fetchRecordsForCollection("app.bsky.graph.follow")).length || 0,
            followsPerDay: ageInDays ? ((await fetchRecordsForCollection("app.bsky.graph.follow")).length) / ageInDays : 0
          },
          "app.bsky.graph.list": (await fetchRecordsForCollection("app.bsky.graph.list")).length || 0,
          "app.bsky.graph.listblock": (await fetchRecordsForCollection("app.bsky.graph.listblock")).length || 0,
          "app.bsky.graph.listitem": (await fetchRecordsForCollection("app.bsky.graph.listitem")).length || 0,
          "app.bsky.graph.starterpack": (await fetchRecordsForCollection("app.bsky.graph.starterpack")).length || 0,
          "{non.app.bsky.collections}": totalNonBskyCollections
        },
        activityLast30Days: {
          profileEdited: (new Date(profile.indexedAt) > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000))
          // For a complete solution, aggregate counts for other collections in the past 30 days.
        },
        alsoKnownAs: {
          totalAkas: akaSet.size,
          activeAkas: (auditLogData && auditLogData.records && auditLogData.records.length)
                      ? auditLogData.records[auditLogData.records.length - 1].alsoKnownAs.length
                      : 0,
          totalBskyAkas,
          totalCustomAkas,
          domainRarity: calculateDomainRarity(profile.handle),
          handleType: profile.handle.includes("bsky.social") ? "default" : "custom"
        },
        analysis: {
          accountAgeStatement: "",   // Filled in narrative below if needed.
          blueskyFeatures: "",
          atprotoEngagement: "",
          domainHistoryStatement: "",
          rotationKeyStatement: "",
          pdsHostStatement: "",
          generationStatement: "invite-only era and were amongst the first 10000 users",
          socialStatusStatement: "",
          narrative: narrative
        }
      };

      // 15. Build final output JSON.
      const finalOutput = {
        message: "accountData retrieved successfully",
        accountData
      };

      document.getElementById("output").textContent = JSON.stringify(finalOutput, null, 2);
    } catch (err) {
      console.error("Error loading account data:", err);
      document.getElementById("output").textContent = JSON.stringify({
        message: "Error retrieving accountData",
        error: err.toString()
      }, null, 2);
    }
  }

  // Run when page loads.
  loadAccountData();
  </script>
</body>
</html>
