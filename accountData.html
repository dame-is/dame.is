<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bluesky Account Production Analysis</title>
  <style>
    body { font-family: sans-serif; margin: 1rem; }
    pre { background: #f8f8f8; padding: 1rem; border: 1px solid #ccc; }
  </style>
</head>
<body>
  <h1>Bluesky Account Production Analysis</h1>
  <pre id="output"></pre>

  <script>
  /***********************************************************************
   * Global settings and basic caching
   ***********************************************************************/
  const did = "did:plc:gq4fo3u6tqzzdkjlwzpb23tj";
  const handle = "dame.bsky.social";
  const serviceEndpoint = "https://enoki.us-east.host.bsky.network";
  const plcDirectoryEndpoint = "https://plc.directory";
  const publicServiceEndpoint = "https://public.api.bsky.app";

  // Basic in-memory cache to avoid duplicate API calls.
  const cache = {};

  /***********************************************************************
   * Helper Functions
   ***********************************************************************/
  // Standard fetch with error checking.
  async function getJSON(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} error for ${url}`);
      }
      return await response.json();
    } catch (err) {
      console.error("Error in getJSON for", url, err);
      throw err;
    }
  }

  // Cached fetch: if we already have data for a URL, return it.
  async function cachedGetJSON(url) {
    if (cache[url]) return cache[url];
    const data = await getJSON(url);
    cache[url] = data;
    return data;
  }

  /***********************************************************************
   * Endpoint calls with pagination and caching
   ***********************************************************************/
  // 1. Fetch Profile data
  async function fetchProfile() {
    const url = `${publicServiceEndpoint}/xrpc/app.bsky.actor.getProfile?actor=${encodeURIComponent(did)}`;
    return await cachedGetJSON(url);
  }

  // 2. Fetch all blobs (pagination using cursor)
  async function fetchAllBlobsCount() {
    let urlBase = `${serviceEndpoint}/xrpc/com.atproto.sync.listBlobs?did=${encodeURIComponent(did)}&limit=1000`;
    let count = 0, cursor = null;
    do {
      const url = urlBase + (cursor ? `&cursor=${cursor}` : '');
      const data = await cachedGetJSON(url);
      // Use data.cids as the key containing the blob identifiers.
      count += Array.isArray(data.cids) ? data.cids.length : 0;
      cursor = data.cursor || null;
    } while (cursor);
    return count;
  }

  // 3. Fetch repo description (which includes a list of collections)
  async function fetchRepoDescription() {
    const url = `${serviceEndpoint}/xrpc/com.atproto.repo.describeRepo?repo=${encodeURIComponent(did)}`;
    return await cachedGetJSON(url);
  }

  // 4. Fetch records from a given collection (pagination using cursor)
  async function fetchRecordsForCollection(collectionName) {
    let urlBase = `${serviceEndpoint}/xrpc/com.atproto.repo.listRecords?repo=${encodeURIComponent(did)}&collection=${encodeURIComponent(collectionName)}&limit=100`;
    let records = [];
    let cursor = null;
    do {
      const url = urlBase + (cursor ? `&cursor=${cursor}` : '');
      const data = await cachedGetJSON(url);
      if (Array.isArray(data.records)) {
        records = records.concat(data.records);
      }
      cursor = data.cursor || null;
    } while (cursor);
    return records;
  }

  // 5. Fetch audit log from PLC Directory
  async function fetchAuditLog() {
    const url = `${plcDirectoryEndpoint}/${encodeURIComponent(did)}/log/audit`;
    return await cachedGetJSON(url);
  }

  // 6. Fetch Author Feed (for engagements)
  async function fetchAuthorFeed() {
    let urlBase = `${publicServiceEndpoint}/xrpc/app.bsky.feed.getAuthorFeed?actor=${encodeURIComponent(did)}&limit=100`;
    let feed = [];
    let cursor = null;
    do {
      const url = urlBase + (cursor ? `&cursor=${cursor}` : '');
      const data = await cachedGetJSON(url);
      if (Array.isArray(data.feed)) {
        feed = feed.concat(data.feed);
      }
      cursor = data.cursor || null;
    } while (cursor);
    return feed;
  }

  /***********************************************************************
   * Calculation Functions
   ***********************************************************************/
  // Calculate age in days and age percentage (based on reference date)
  function calculateAge(createdAt) {
    const created = new Date(createdAt);
    const today = new Date();
    const diffTime = Math.abs(today - created);
    const ageInDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    // Reference date: 2022-11-17T00:35:16.391Z
    const refDate = new Date("2022-11-17T00:35:16.391Z");
    const daysSinceRef = Math.floor(Math.abs(today - refDate) / (1000 * 60 * 60 * 24));
    const agePercentage = daysSinceRef > 0 ? ageInDays / daysSinceRef : 0;
    return { ageInDays, agePercentage };
  }

  // Helper function: extract author DIDs from a reply object.
  function getReplyAuthors(reply) {
    const authors = [];
    if (reply.parent && reply.parent.author) {
      authors.push(reply.parent.author);
    }
    if (reply.root && reply.root.author) {
      authors.push(reply.root.author);
    }
    // If your data has a grandparent, you could add:
    if (reply.grandparent && reply.grandparent.author) {
      authors.push(reply.grandparent.author);
    }
    return authors;
  }

  // Calculate posting style using the provided criteria.
  // Expects an object with posts stats.
  function calculatePostingStyle(stats) {
    const {
      onlyPostsPerDay = 0,
      replyOtherPercentage = 0,
      textPercentage = 0,
      imagePercentage = 0,
      videoPercentage = 0,
      linkPercentage = 0,
      altTextPercentage = 0,
      postsPerDay = 0
    } = stats;

    // Rule: if not enough post frequency then maybe Lurker.
    if (postsPerDay < 0.1 && stats.totalBskyRecordsPerDay > 0.3) {
      return "Lurker";
    }

    if (onlyPostsPerDay > 0.8 && replyOtherPercentage >= 0.3) {
      if (textPercentage > linkPercentage && textPercentage > imagePercentage && textPercentage > videoPercentage) {
        return "Engaged Text Poster";
      }
      if (imagePercentage > linkPercentage && imagePercentage > textPercentage && imagePercentage > videoPercentage) {
        return (altTextPercentage <= 0.3) ? "Engaged Image Poster who's bad at alt text" : "Engaged Image Poster";
      }
      if (linkPercentage > imagePercentage && linkPercentage > textPercentage && linkPercentage > videoPercentage) {
        return "Engaged Link Poster";
      }
      if (videoPercentage > imagePercentage && videoPercentage > textPercentage && videoPercentage > linkPercentage) {
        return "Engaged Video Poster";
      }
      return "Engaged Poster";
    } else if (onlyPostsPerDay > 0.8 && replyOtherPercentage < 0.3) {
      if (textPercentage > linkPercentage && textPercentage > imagePercentage && textPercentage > videoPercentage) {
        return "Unengaged Text Poster";
      }
      if (imagePercentage > linkPercentage && imagePercentage > textPercentage && imagePercentage > videoPercentage) {
        return (altTextPercentage <= 0.3) ? "Unengaged Image Poster who's bad at alt text" : "Unengaged Image Poster";
      }
      if (linkPercentage > imagePercentage && linkPercentage > textPercentage && linkPercentage > videoPercentage) {
        return "Unengaged Link Poster";
      }
      if (videoPercentage > imagePercentage && videoPercentage > textPercentage && videoPercentage > linkPercentage) {
        return "Unengaged Video Poster";
      }
      return "Unengaged Poster";
    }
    if (replyOtherPercentage >= 0.5) return "Reply Guy";
    if (stats.quoteOtherPercentage >= 0.5) return "Quote Guy";
    if (stats.repostOtherPercentage >= 0.5) return "Repost Guy";

    return "Unknown";
  }

  // Calculate social status (one label)
  function calculateSocialStatus({ ageInDays, followersCount, followsCount }) {
    const followPercentage = followersCount > 0 ? followsCount / followersCount : 0;
    if (ageInDays < 30) return "Newbie";
    if (followPercentage < 0.5) {
      if (followersCount >= 500 && followersCount < 10000) return "Micro Influencer";
      if (followersCount >= 10000 && followersCount < 100000) return "Influencer";
      if (followersCount >= 100000) return "Celebrity";
    }
    return "Community Member";
  }

  // Calculate activity status given rate (records per day)
  function calculateActivityStatus(rate) {
    if (rate === 0) return "inactive";
    if (rate > 0 && rate < 1) return "eepy";
    if (rate >= 1 && rate < 10) return "awake";
    if (rate >= 10) return "wired";
  }

  // Calculate profile completion: complete/incomplete/not started.
  function calculateProfileCompletion(profile) {
    const hasDisplayName = Boolean(profile.displayName && profile.displayName.trim());
    const hasBanner = Boolean(profile.banner && profile.banner.trim());
    const hasDescription = Boolean(profile.description && profile.description.trim());
    if (hasDisplayName && hasBanner && hasDescription) return "complete";
    if (hasDisplayName || hasBanner || hasDescription) return "incomplete";
    return "not started";
  }

  // Calculate domain rarity based on handle and its length.
  // For handles including "bsky.social", we count the entire string.
  // For custom domains:
  //   - If the handle ends with .com, .org, or .net, we use the domain part (after the first dot).
  //   - Otherwise, we use the entire string.
  function calculateDomainRarity(handle) {
    if (handle.includes("bsky.social")) {
      // For bsky handles, use the entire handle length.
      const len = handle.length;
      if (len >= 21) return "very common";
      if (len >= 18 && len <= 20) return "common";
      if (len === 17) return "uncommon";
      if (len === 16) return "rare";
      if (len === 15) return "very rare";
      if (len <= 14) return "extremely rare";
    } else {
      // For custom domains, check if the handle ends with one of the standard TLDs.
      const standardTLDs = [".com", ".org", ".net"];
      const hasStandardTLD = standardTLDs.some(tld => handle.endsWith(tld));
      let len;
      if (hasStandardTLD) {
        // Use only the domain part (e.g. everything after the first dot).
        const parts = handle.split(".");
        // Rejoin everything after the first element:
        const domain = parts.slice(1).join(".");
        len = domain.length;
        if (len >= 15) return "very common";
        if (len >= 12 && len <= 14) return "common";
        if (len >= 9 && len <= 11) return "uncommon";
        if (len >= 7 && len <= 8) return "rare";
        if (len === 6) return "very rare";
        if (len <= 5) return "extremely rare";
      } else {
        // Otherwise, use the entire handle.
        len = handle.length;
        if (len >= 14) return "very common";
        if (len >= 11 && len <= 13) return "common";
        if (len >= 8 && len <= 10) return "uncommon";
        if (len >= 6 && len <= 7) return "rare";
        if (len === 5) return "very rare";
        if (len <= 4) return "extremely rare";
      }
    }
    return "unknown";
  }

  // Calculate era based on createdAt date.
  function calculateEra(createdAt) {
    const created = new Date(createdAt);
    if (created >= new Date("2022-11-16") && created <= new Date("2023-01-31")) {
      return "pre-history";
    } else if (created >= new Date("2023-02-01") && created <= new Date("2024-01-31")) {
      return "invite-only";
    } else if (created > new Date("2024-01-31")) {
      return "public-release";
    }
    return "unknown";
  }

  // Calculate aggregate records for the account by iterating over each collection.
  async function calculateRecordsAggregate(collectionNames) {
    let totalRecords = 0;
    let totalBskyRecords = 0;
    let totalNonBskyRecords = 0;
    for (const col of collectionNames) {
      const recs = await fetchRecordsForCollection(col);
      totalRecords += recs.length;
      if (col.indexOf("app.bsky") !== -1) {
        totalBskyRecords += recs.length;
      } else {
        totalNonBskyRecords += recs.length;
      }
    }
    return { totalRecords, totalBskyRecords, totalNonBskyRecords };
  }

    // Calculate engagements for the account using the author feed.
    async function calculateEngagements() {
    const feed = await fetchAuthorFeed();
    let likesReceived = 0;
    let repostsReceived = 0;
    let quotesReceived = 0;
    let repliesReceived = 0;

    for (const item of feed) {
      if (item && item.post) {
        // Skip repost reasons
        if (JSON.stringify(item.post).includes("#reasonRepost")) continue;

        likesReceived += item.post.likeCount || 0;
        repostsReceived += item.post.repostCount || 0;
        quotesReceived += item.post.quoteCount || 0;
        repliesReceived += item.post.replyCount || 0;
      }
    }

    return {
      likesReceived,
      repostsReceived,
      quotesReceived,
      repliesReceived,
    };
  }

  // Build the analysis narrative paragraphs based on the criteria.
  function buildAnalysisNarrative(accountData) {
    const { profile, activityAll, alsoKnownAs } = accountData;
    const { ageInDays, agePercentage } = calculateAge(profile.createdAt);
    let accountAgeStatement = "";
    if (agePercentage >= 0.97) {
      accountAgeStatement = "since the very beginning and is";
    } else if (agePercentage >= 0.7) {
      accountAgeStatement = "for a very long time and is";
    } else if (agePercentage >= 0.5) {
      accountAgeStatement = "for a long time and is";
    } else if (agePercentage >= 0.1) {
      accountAgeStatement = "for awhile and is";
    } else if (agePercentage >= 0.02) {
      accountAgeStatement = "for only a short period of time and is";
    } else {
      accountAgeStatement = "for barely any time at all";
    }
    const totalBskyCollections = activityAll.totalBskyCollections || 0;
    let blueskyFeatures = "";
    if (totalBskyCollections >= 12) {
      blueskyFeatures = "they are using all of Bluesky's core features";
    } else if (totalBskyCollections >= 8) {
      blueskyFeatures = "they are using most of Bluesky’s core features";
    } else if (totalBskyCollections >= 3) {
      blueskyFeatures = "they are using some of Bluesky’s core features";
    } else {
      blueskyFeatures = "they haven't used any of Bluesky's core features yet";
    }
    const totalNonBskyCollections = activityAll.totalNonBskyCollections || 0;
    const totalNonBskyRecords = activityAll.totalNonBskyRecords || 0;
    let atprotoEngagement = "";
    if (totalNonBskyCollections >= 10 && totalNonBskyRecords > 100) {
      atprotoEngagement = "is extremely engaged, having used many different services or tools";
    } else if (totalNonBskyCollections >= 5 && totalNonBskyRecords > 50) {
      atprotoEngagement = "is very engaged, having used many different services or tools";
    } else if (totalNonBskyCollections > 0 && totalNonBskyRecords > 5) {
      atprotoEngagement = "has dipped their toes in the water, but has yet to go deeper";
    } else {
      atprotoEngagement = "has not yet explored what's out there";
    }
    let domainHistoryStatement = "";
    if (alsoKnownAs.totalCustomAkas > 0 && profile.handle.includes("bsky.social")) {
      domainHistoryStatement = "They've used a custom domain name at some point but are currently using a default Bluesky handle";
    } else if (!profile.handle.includes("bsky.social")) {
      domainHistoryStatement = "They currently are using a custom domain";
    } else if (alsoKnownAs.totalAkas > 2 && !profile.handle.includes("bsky.social")) {
      domainHistoryStatement = "They have a custom domain set and have a history of using different aliases";
    } else {
      domainHistoryStatement = "They still have a default Bluesky handle";
    }
    let rotationKeyStatement = (accountData.rotationKeys === 2)
      ? "They don't have their own rotation key set"
      : "They have their own rotation key set";
    let pdsHostStatement = serviceEndpoint.includes("bsky.network")
      ? "their PDS is hosted by a Bluesky mushroom"
      : "their PDS is hosted by either a third-party or themselves";

    const narrative1 = `${profile.displayName} has been on the network ${accountAgeStatement} ${calculateActivityStatus(activityAll.totalRecordsPerDay)}. ` +
      `Their profile is ${calculateProfileCompletion(profile)}, and ${blueskyFeatures}. ` +
      `When it comes to the broader AT Proto ecosystem, this identity ${atprotoEngagement}. ` +
      `${domainHistoryStatement} which is ${calculateDomainRarity(profile.handle)}. ` +
      `${rotationKeyStatement}, and ${pdsHostStatement}.`;

    const era = calculateEra(profile.createdAt);
    const postingStyle = accountData.postingStyle;
    const socialStatus = accountData.socialStatus;
    const mediaType = "a mix of text, images, and video";
    const followRatio = profile.followersCount > 0 
      ? (profile.followsCount / profile.followersCount).toFixed(2) 
      : 0;
    const narrative2 = `${profile.displayName} first joined Bluesky during the ${era} era. ` +
      `Their style of posting is "${postingStyle}". ` +
      `Their posts consist of ${mediaType}. ` +
      `They are ${socialStatus} as is indicated by their follower count of ${profile.followersCount} and their follower/following ratio of ${followRatio}.`;

    return narrative1 + "\n\n" + narrative2;
  }

  /***********************************************************************
   * Main Function – Build accountData and final JSON object.
   ***********************************************************************/
  async function loadAccountData() {
    try {
      // 1. Get basic profile (and use it for several fields)
      const profile = await fetchProfile();

      // 2. Age details
      const { ageInDays, agePercentage } = calculateAge(profile.createdAt);

      // 3. Blobs count and per-day/post calculations
      const blobsCount = await fetchAllBlobsCount();

        // 4. Repo description gives collections.
        const repoDescription = await fetchRepoDescription();
        const collections = repoDescription.collections || [];
        const totalCollections = collections.length;

        // 5. Aggregate record counts for all collections dynamically.
        const collectionStats = {};
        for (const collection of collections) {
        const records = await fetchRecordsForCollection(collection);
        const recordCount = records.length;
        const recordsPerDay = ageInDays ? recordCount / ageInDays : 0;

        // Add to collection stats
        collectionStats[collection] = {
            count: recordCount,
            recordsPerDay,
        };
        }

        const bskyCollectionNames = collections.filter(col => col.includes("app.bsky"));
        const totalBskyCollections = bskyCollectionNames.length;
        const totalNonBskyCollections = totalCollections - totalBskyCollections;

        // 6. Aggregate totals
        const totalRecords = Object.values(collectionStats).reduce((sum, stat) => sum + stat.count, 0);
        const totalRecordsPerDay = ageInDays ? totalRecords / ageInDays : 0;

        // 6.5. Compute Bsky-specific and non-Bsky-specific totals
        const totalBskyRecords = bskyCollectionNames.reduce(
        (sum, col) => sum + (collectionStats[col]?.count || 0),
        0
        );
        const totalBskyRecordsPerDay = ageInDays ? totalBskyRecords / ageInDays : 0;
        const totalNonBskyRecords = totalRecords - totalBskyRecords;
        const totalNonBskyRecordsPerDay = ageInDays ? totalNonBskyRecords / ageInDays : 0;

      // 7. For detailed post statistics.
      const postsRecords = await fetchRecordsForCollection("app.bsky.feed.post");
      const postsCount = profile.postsCount || postsRecords.length;
      function filterRecords(records, testFunc) {
        return records.filter(testFunc).length;
      }
      // Count only posts (records with no "reply" key).
      const onlyPosts = filterRecords(postsRecords, rec => !rec.value.hasOwnProperty("reply"));
      const onlyPostsPerDay = ageInDays ? onlyPosts / ageInDays : 0;
      // Count replies (records with a "reply" key).
      const onlyReplies = filterRecords(postsRecords, rec => rec.value.hasOwnProperty("reply"));
      const onlyRepliesPerDay = ageInDays ? onlyReplies / ageInDays : 0;
      
      // New logic for replies.
      const onlyRepliesToSelf = postsRecords.filter(rec => {
        // Check if the "reply" object exists in the "value" field
        if (!rec.value || !rec.value.reply || !rec.value.reply.parent) return false;

        // Check if the "parent" object has a "uri" and if it contains the DID
        return rec.value.reply.parent.uri.includes(did);
        }).length;
      const onlyRepliesToSelfPerDay = ageInDays ? onlyRepliesToSelf / ageInDays : 0;
      const onlyRepliesToOthers = onlyReplies - onlyRepliesToSelf;
      const onlyRepliesToOthersPerDay = ageInDays ? onlyRepliesToOthers / ageInDays : 0;

      // Count quotes.
      const onlyQuotes = filterRecords(postsRecords, rec => rec.value.embed && rec.value.embed["$type"] === "app.bsky.embed.record");
      const onlyQuotesPerDay = ageInDays ? onlyQuotes / ageInDays : 0;
      const onlySelfQuotes = filterRecords(postsRecords, rec => {
        // Check if the "embed" object exists and is of the correct type
        if (
            !rec.value || 
            !rec.value.embed || 
            (rec.value.embed["$type"] !== "app.bsky.embed.record" && rec.value.embed["$type"] !== "app.bsky.embed.recordWithMedia")
        ) {
            return false;
        }

        // Match either `record.record.uri` or `record.uri` containing the DID
        const embedRecord = rec.value.embed.record;
        return (
            (embedRecord.record && embedRecord.record.uri && embedRecord.record.uri.includes(did)) ||
            (embedRecord.uri && embedRecord.uri.includes(did))
        );
        });
      const onlySelfQuotesPerDay = ageInDays ? onlySelfQuotes / ageInDays : 0;
      const onlyOtherQuotes = onlyQuotes - onlySelfQuotes;
      const onlyOtherQuotesPerDay = ageInDays ? onlyOtherQuotes / ageInDays : 0;

      // Count reposts.
      const repostRecords = await fetchRecordsForCollection("app.bsky.feed.repost");
      const onlyReposts = repostRecords.length;
      const onlyRepostsPerDay = ageInDays ? onlyReposts / ageInDays : 0;
      const onlySelfReposts = filterRecords(repostRecords, rec => {
        // Ensure the "subject" object and "uri" property exist
        if (!rec.value || !rec.value.subject || !rec.value.subject.uri) return false;

        // Check if the "uri" contains the DID
        return rec.value.subject.uri.includes(did);
        });
      const onlySelfRepostsPerDay = ageInDays ? onlySelfReposts / ageInDays : 0;
      const onlyOtherReposts = onlyReposts - onlySelfReposts;
      const onlyOtherRepostsPerDay = ageInDays ? onlyOtherReposts / ageInDays : 0;

      // Count posts with images.
      const postsWithImages = filterRecords(postsRecords, rec => rec.value.embed && rec.value.embed["$type"] === "app.bsky.embed.images");
      const imagePostsPerDay = ageInDays ? postsWithImages / ageInDays : 0;
      const imagePostsAltText = filterRecords(postsRecords, rec => {
        // Check if the embed object exists and is of the correct type
        if (!rec.value.embed || rec.value.embed["$type"] !== "app.bsky.embed.images") {
            return false;
        }

        // Check if any image in the images array contains an "alt" value
        return rec.value.embed.images && rec.value.embed.images.some(image => image.alt && image.alt.trim());
        });
      const imagePostsNoAltText = postsWithImages - imagePostsAltText;
      const altTextPercentage = postsWithImages ? imagePostsAltText / postsWithImages : 0;
      // Count posts with only text.
      const postsWithOnlyText = filterRecords(postsRecords, rec =>
        !rec.value.embed && !rec.value.reply && !(rec.value.facets && JSON.stringify(rec.value.facets).indexOf("app.bsky.richtext.facet#link") !== -1)
      );
      const textPostsPerDay = ageInDays ? postsWithOnlyText / ageInDays : 0;
        // Count posts with mentions.
        const postsWithMentions = filterRecords(postsRecords, rec => {
        if (!rec.value || !rec.value.facets) return false;

        return rec.value.facets.some(facet =>
            facet.features && facet.features.some(feature => feature["$type"] === "app.bsky.richtext.facet#mention")
        );
        });
      const mentionPostsPerDay = ageInDays ? postsWithMentions / ageInDays : 0;
      // Count posts with video.
      const postsWithVideo = filterRecords(postsRecords, rec => rec.value.embed && rec.value.embed["$type"] === "app.bsky.embed.video");
      const videoPostsPerDay = ageInDays ? postsWithVideo / ageInDays : 0;
      // Count posts with links.
      const postsWithLinks = filterRecords(postsRecords, rec => {
        if (rec.value.facets && rec.value.facets.features && rec.value.facets.features.some(f => f["$type"] === "app.bsky.richtext.facet#link")) return true;
        if (rec.value.embed && rec.value.embed["$type"] === "app.bsky.embed.external") return true;
        return false;
      });
      const linkPostsPerDay = ageInDays ? postsWithLinks / ageInDays : 0;

      const postStats = {
        postsCount,
        postsPerDay: ageInDays ? postsCount / ageInDays : 0,
        onlyPosts,
        onlyPostsPerDay,
        onlyReplies,
        onlyRepliesPerDay,
        onlyRepliesToSelf,
        onlyRepliesToSelfPerDay,
        onlyRepliesToOthers,
        onlyRepliesToOthersPerDay,
        onlyQuotes,
        onlyQuotesPerDay,
        onlySelfQuotes,
        onlySelfQuotesPerDay,
        onlyOtherQuotes,
        onlyOtherQuotesPerDay,
        onlyReposts,
        onlyRepostsPerDay,
        onlySelfReposts,
        onlySelfRepostsPerDay,
        onlyOtherReposts,
        onlyOtherRepostsPerDay,
        postsWithImages,
        imagePostsPerDay,
        postsWithOnlyText,
        textPostsPerDay,
        postsWithMentions,
        mentionPostsPerDay,
        postsWithVideo,
        videoPostsPerDay,
        postsWithLinks,
        linkPostsPerDay,
        imagePostsAltText,
        imagePostsNoAltText,
        altTextPercentage,
        replyPercentage: postsCount ? onlyReplies / postsCount : 0,
        replySelfPercentage: postsCount ? onlyRepliesToSelf / postsCount : 0,
        replyOtherPercentage: postsCount ? onlyRepliesToOthers / postsCount : 0,
        quotePercentage: postsCount ? onlyQuotes / postsCount : 0,
        quoteSelfPercentage: postsCount ? onlySelfQuotes / postsCount : 0,
        quoteOtherPercentage: postsCount ? onlyOtherQuotes / postsCount : 0,
        repostPercentage: postsCount ? onlyReposts / postsCount : 0,
        repostSelfPercentage: postsCount ? onlySelfReposts / postsCount : 0,
        repostOtherPercentage: postsCount ? onlyOtherReposts / postsCount : 0,
        textPercentage: postsCount ? postsWithOnlyText / postsCount : 0,
        linkPercentage: postsCount ? postsWithLinks / postsCount : 0,
        imagePercentage: postsCount ? postsWithImages / postsCount : 0,
        videoPercentage: postsCount ? postsWithVideo / postsCount : 0,
        totalBskyRecordsPerDay,
        totalNonBskyRecordsPerDay,
      };

      // 8. Parse audit log for rotation keys and alsoKnownAs information.
      const rawAuditData = await fetchAuditLog();
      let auditRecords = Array.isArray(rawAuditData) ? rawAuditData : Object.values(rawAuditData);
      const plcOperations = auditRecords.length;
      let rotationKeys = 0;
      let activeAkas = 0;
      let akaSet = new Set();

      if (plcOperations > 0) {
        auditRecords.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
        const latestRecord = auditRecords[auditRecords.length - 1];
        if (latestRecord.operation && Array.isArray(latestRecord.operation.rotationKeys)) {
          rotationKeys = latestRecord.operation.rotationKeys.length;
        }
        if (latestRecord.operation && Array.isArray(latestRecord.operation.alsoKnownAs)) {
          activeAkas = latestRecord.operation.alsoKnownAs.length;
        }
        auditRecords.forEach(record => {
          if (record.operation && Array.isArray(record.operation.alsoKnownAs)) {
            record.operation.alsoKnownAs.forEach(alias => {
              akaSet.add(alias);
            });
          }
        });
      }
      const totalAkas = akaSet.size;
      const totalBskyAkas = Array.from(akaSet).filter(alias => alias.includes("bsky.social")).length;
      const totalCustomAkas = totalAkas - totalBskyAkas;

      // 9. Compute engagements from author feed.
      const engagementsReceived = await calculateEngagements();

      // 10. Compute overall activity statuses.
      const overallActivityStatus = calculateActivityStatus(totalRecordsPerDay);
      const bskyActivityStatus = calculateActivityStatus(totalBskyRecordsPerDay);
      const atprotoActivityStatus = calculateActivityStatus(totalNonBskyRecordsPerDay);

      // 11. Compute posting style.
      const postingStyle = calculatePostingStyle({
        ...postStats,
        totalBskyRecordsPerDay
      });

      // 12. Compute social status.
      const socialStatus = calculateSocialStatus({
        ageInDays,
        followersCount: profile.followersCount || 0,
        followsCount: profile.followsCount || 0
      });

      // 13. Build analysis narrative paragraphs.
      const narrative = buildAnalysisNarrative({
        profile,
        activityAll: {
          totalRecords,
          totalRecordsPerDay,
          totalBskyCollections,
          totalNonBskyCollections,
          totalBskyRecords,
          totalBskyRecordsPerDay,
          totalBskyRecordsPercentage,
          totalNonBskyRecords,
          totalNonBskyRecordsPerDay,
          totalNonBskyRecordsPercentage,
        },
        postingStyle,
        socialStatus,
        alsoKnownAs: {
          totalAkas,
          totalCustomAkas,
          totalBskyAkas
        }
      });

      // 14. Construct final accountData JSON.
      const accountData = {
        profile: {
          ...profile,
          did: profile.did || did
        },
        displayName: profile.displayName,
        handle: profile.handle,
        did: profile.did || did,
        profileEditedDate: profile.indexedAt,
        profileCompletion: calculateProfileCompletion(profile),
        scoreGeneratedAt: new Date().toISOString(),
        serviceEndpoint,
        pdsType: serviceEndpoint.includes("bsky.network") ? "Bluesky" : "Third-party",
        createdAt: profile.createdAt,
        ageInDays,
        agePercentage,
        blobsCount,
        blobsPerDay: ageInDays ? blobsCount / ageInDays : 0,
        blobsPerPost: postsCount ? blobsCount / postsCount : 0,
        blobsPerImagePost: postsWithImages ? blobsCount / postsWithImages : 0,
        followersCount: profile.followersCount,
        followsCount: profile.followsCount,
        followPercentage: profile.followersCount ? profile.followsCount / profile.followersCount : 0,
        postsCount,
        rotationKeys,
        era: calculateEra(profile.createdAt),
        postingStyle,
        socialStatus,
        activityAll: {
          activityStatus: overallActivityStatus,
          bskyActivityStatus,
          atprotoActivityStatus,
          totalCollections,
          totalBskyCollections,
          totalNonBskyCollections,
          totalRecords,
          totalRecordsPerDay,
          totalBskyRecords,
          totalBskyRecordsPerDay,
          totalBskyRecordsPercentage,
          totalNonBskyRecords,
          totalNonBskyRecordsPerDay,
          totalNonBskyRecordsPercentage,
          plcOperations,
          "app.bsky.feed.post": {
            postsCount,
            postsPerDay: ageInDays ? postsCount / ageInDays : 0,
            onlyPosts,
            onlyPostsPerDay,
            onlyReplies,
            onlyRepliesPerDay,
            onlyRepliesToSelf,
            onlyRepliesToSelfPerDay,
            onlyRepliesToOthers,
            onlyRepliesToOthersPerDay,
            onlyQuotes,
            onlyQuotesPerDay,
            onlySelfQuotes,
            onlySelfQuotesPerDay,
            onlyOtherQuotes,
            onlyOtherQuotesPerDay,
            onlyReposts,
            onlyRepostsPerDay,
            onlySelfReposts,
            onlySelfRepostsPerDay,
            onlyOtherReposts,
            onlyOtherRepostsPerDay,
            postsWithImages,
            imagePostsPerDay,
            postsWithOnlyText,
            textPostsPerDay,
            postsWithMentions,
            mentionPostsPerDay,
            postsWithVideo,
            videoPostsPerDay,
            postsWithLinks,
            linkPostsPerDay,
            imagePostsAltText,
            imagePostsNoAltText,
            altTextPercentage,
            replyPercentage: postsCount ? onlyReplies / postsCount : 0,
            replySelfPercentage: postsCount ? onlyRepliesToSelf / postsCount : 0,
            replyOtherPercentage: postsCount ? onlyRepliesToOthers / postsCount : 0,
            quotePercentage: postsCount ? onlyQuotes / postsCount : 0,
            quoteSelfPercentage: postsCount ? onlySelfQuotes / postsCount : 0,
            quoteOtherPercentage: postsCount ? onlyOtherQuotes / postsCount : 0,
            repostPercentage: postsCount ? onlyReposts / postsCount : 0,
            repostSelfPercentage: postsCount ? onlySelfReposts / postsCount : 0,
            repostOtherPercentage: postsCount ? onlyOtherReposts / postsCount : 0,
            textPercentage: postsCount ? postsWithOnlyText / postsCount : 0,
            linkPercentage: postsCount ? postsWithLinks / postsCount : 0,
            imagePercentage: postsCount ? postsWithImages / postsCount : 0,
            videoPercentage: postsCount ? postsWithVideo / postsCount : 0
          },
          collections: collectionStats
        },
        activityLast30Days: {
          profileEdited: (new Date(profile.indexedAt) > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000))
        },
        alsoKnownAs: {
          totalAkas: akaSet.size,
          activeAkas,
          totalBskyAkas,
          totalCustomAkas,
          domainRarity: calculateDomainRarity(profile.handle),
          handleType: profile.handle.includes("bsky.social") ? "default" : "custom"
        },
        analysis: {
          accountAgeStatement,
          blueskyFeatures,
          atprotoEngagement,
          domainHistoryStatement,
          rotationKeyStatement,
          pdsHostStatement,
          generationStatement,
          socialStatusStatement,
          narrative: narrative
        }
      };

      // 15. Build final output JSON.
      const finalOutput = {
        message: "accountData retrieved successfully",
        accountData
      };

      document.getElementById("output").textContent = JSON.stringify(finalOutput, null, 2);
    } catch (err) {
      console.error("Error loading account data:", err);
      document.getElementById("output").textContent = JSON.stringify({
        message: "Error retrieving accountData",
        error: err.toString()
      }, null, 2);
    }
  }

  // Run when page loads.
  loadAccountData();
  </script>
</body>
</html>
