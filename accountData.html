<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="images/favicon.ico" type="image/x-icon">
  <title>Bluesky Account Production Analysis</title>
  <script src="https://kit.fontawesome.com/830b363cf0.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="/css/styles.css">
  <!-- JSONEditor CSS -->
  <link href="https://cdn.jsdelivr.net/npm/jsoneditor@9.5.6/dist/jsoneditor.min.css" rel="stylesheet" type="text/css">
  <style>
    main { max-width: 800px; }
    pre { background: #f8f8f8; padding: 1rem; border: 1px solid #ccc; overflow: auto; }
    #jsoneditor { height: 400px; border: 1px solid #ccc; margin-bottom: 2rem; }
  </style>
</head>
<body>
  <!-- Navigation -->
  <div id="nav"></div>

  <!-- Main Content -->
  <main>
      <div id="analysis">
        <h1>Bluesky Account Production Analysis</h1>

        <!-- Prettier JSON Viewer Section -->
        <h2>Interactive JSON Viewer</h2>
        <div id="jsoneditor"></div>
        
        <!-- Plain JSON Output -->
        <h2>Raw JSON Output</h2>
        <pre id="output"></pre>
      
        <!-- JSONEditor JS -->
        <script src="https://cdn.jsdelivr.net/npm/jsoneditor@9.5.6/dist/jsoneditor.min.js"></script>
        
        <script>
        /***********************************************************************
         * Global settings and basic caching
         ***********************************************************************/
        const did = "did:plc:gq4fo3u6tqzzdkjlwzpb23tj";
        const handle = "dame.bsky.social";
        const serviceEndpoint = "https://enoki.us-east.host.bsky.network";
        const plcDirectoryEndpoint = "https://plc.directory";
        const publicServiceEndpoint = "https://public.api.bsky.app";
      
        // Basic in-memory cache to avoid duplicate API calls.
        const cache = {};
      
        /***********************************************************************
         * Helper Functions
         ***********************************************************************/
        // Standard fetch with error checking.
        async function getJSON(url) {
          try {
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(`HTTP ${response.status} error for ${url}`);
            }
            return await response.json();
          } catch (err) {
            console.error("Error in getJSON for", url, err);
            throw err;
          }
        }
      
        // Cached fetch: if we already have data for a URL, return it.
        async function cachedGetJSON(url) {
          if (cache[url]) return cache[url];
          const data = await getJSON(url);
          cache[url] = data;
          return data;
        }
      
        /***********************************************************************
         * Endpoint calls with pagination and caching
         ***********************************************************************/
        // 1. Fetch Profile data
        async function fetchProfile() {
          const url = `${publicServiceEndpoint}/xrpc/app.bsky.actor.getProfile?actor=${encodeURIComponent(did)}`;
          return await cachedGetJSON(url);
        }
      
        // 2. Fetch all blobs (pagination using cursor)
        async function fetchAllBlobsCount() {
          let urlBase = `${serviceEndpoint}/xrpc/com.atproto.sync.listBlobs?did=${encodeURIComponent(did)}&limit=1000`;
          let count = 0, cursor = null;
          do {
            const url = urlBase + (cursor ? `&cursor=${cursor}` : '');
            const data = await cachedGetJSON(url);
            // Use data.cids as the key containing the blob identifiers.
            count += Array.isArray(data.cids) ? data.cids.length : 0;
            cursor = data.cursor || null;
          } while (cursor);
          return count;
        }
      
        // 3. Fetch repo description (which includes a list of collections)
        async function fetchRepoDescription() {
          const url = `${serviceEndpoint}/xrpc/com.atproto.repo.describeRepo?repo=${encodeURIComponent(did)}`;
          return await cachedGetJSON(url);
        }
      
        // 4. Fetch records from a given collection (pagination using cursor)
        async function fetchRecordsForCollection(collectionName) {
          let urlBase = `${serviceEndpoint}/xrpc/com.atproto.repo.listRecords?repo=${encodeURIComponent(did)}&collection=${encodeURIComponent(collectionName)}&limit=100`;
          let records = [];
          let cursor = null;
          do {
            const url = urlBase + (cursor ? `&cursor=${cursor}` : '');
            const data = await cachedGetJSON(url);
            if (Array.isArray(data.records)) {
              records = records.concat(data.records);
            }
            cursor = data.cursor || null;
          } while (cursor);
          return records;
        }
      
        // 5. Fetch audit log from PLC Directory
        async function fetchAuditLog() {
          const url = `${plcDirectoryEndpoint}/${encodeURIComponent(did)}/log/audit`;
          return await cachedGetJSON(url);
        }
      
        // 6. Fetch Author Feed (for engagements)
        async function fetchAuthorFeed() {
          let urlBase = `${publicServiceEndpoint}/xrpc/app.bsky.feed.getAuthorFeed?actor=${encodeURIComponent(did)}&limit=100`;
          let feed = [];
          let cursor = null;
          do {
            const url = urlBase + (cursor ? `&cursor=${cursor}` : '');
            const data = await cachedGetJSON(url);
            if (Array.isArray(data.feed)) {
              feed = feed.concat(data.feed);
            }
            cursor = data.cursor || null;
          } while (cursor);
          return feed;
        }
      
        /***********************************************************************
         * Calculation Functions
         ***********************************************************************/
        // Helper function to round numbers to two decimal places
        function roundToTwo(num) {
          return Number(num.toFixed(2));
        }
      
        // Recursive function to round all numerical values in an object
        function roundNumbers(obj) {
          if (Array.isArray(obj)) {
            return obj.map(roundNumbers);
          } else if (typeof obj === 'object' && obj !== null) {
            const newObj = {};
            for (let key in obj) {
              newObj[key] = roundNumbers(obj[key]);
            }
            return newObj;
          } else if (typeof obj === 'number') {
            return roundToTwo(obj);
          } else {
            return obj;
          }
        }
      
        // Calculate age in days and age percentage (based on reference date)
        function calculateAge(createdAt) {
          const created = new Date(createdAt);
          const today = new Date();
          const diffTime = Math.abs(today - created);
          const ageInDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
          // Reference date: 2022-11-17T00:35:16.391Z
          const refDate = new Date("2022-11-17T00:35:16.391Z");
          const daysSinceRef = Math.floor(Math.abs(today - refDate) / (1000 * 60 * 60 * 24));
          const agePercentage = daysSinceRef > 0 ? ageInDays / daysSinceRef : 0;
          return { ageInDays, agePercentage };
        }
      
        // Helper function: extract author DIDs from a reply object.
        function getReplyAuthors(reply) {
          const authors = [];
          if (reply.parent && reply.parent.author) {
            authors.push(reply.parent.author);
          }
          if (reply.root && reply.root.author) {
            authors.push(reply.root.author);
          }
          // If your data has a grandparent, you could add:
          if (reply.grandparent && reply.grandparent.author) {
            authors.push(reply.grandparent.author);
          }
          return authors;
        }
      
        // Calculate posting style using the provided criteria.
        // Expects an object with posts stats.
        function calculatePostingStyle(stats) {
          const {
            onlyPostsPerDay = 0,
            replyOtherPercentage = 0,
            textPercentage = 0,
            imagePercentage = 0,
            videoPercentage = 0,
            linkPercentage = 0,
            altTextPercentage = 0,
            postsPerDay = 0
          } = stats;
      
          // Rule: if not enough post frequency then maybe Lurker.
          if (postsPerDay < 0.1 && stats.totalBskyRecordsPerDay > 0.3) {
            return "Lurker";
          }
      
          if (onlyPostsPerDay > 0.8 && replyOtherPercentage >= 0.3) {
            if (textPercentage > linkPercentage && textPercentage > imagePercentage && textPercentage > videoPercentage) {
              return "Engaged Text Poster";
            }
            if (imagePercentage > linkPercentage && imagePercentage > textPercentage && imagePercentage > videoPercentage) {
              return (altTextPercentage <= 0.3) ? "Engaged Image Poster who's bad at alt text" : "Engaged Image Poster";
            }
            if (linkPercentage > imagePercentage && linkPercentage > textPercentage && linkPercentage > videoPercentage) {
              return "Engaged Link Poster";
            }
            if (videoPercentage > imagePercentage && videoPercentage > textPercentage && videoPercentage > linkPercentage) {
              return "Engaged Video Poster";
            }
            return "Engaged Poster";
          } else if (onlyPostsPerDay > 0.8 && replyOtherPercentage < 0.3) {
            if (textPercentage > linkPercentage && textPercentage > imagePercentage && textPercentage > videoPercentage) {
              return "Unengaged Text Poster";
            }
            if (imagePercentage > linkPercentage && imagePercentage > textPercentage && imagePercentage > videoPercentage) {
              return (altTextPercentage <= 0.3) ? "Unengaged Image Poster who's bad at alt text" : "Unengaged Image Poster";
            }
            if (linkPercentage > imagePercentage && linkPercentage > textPercentage && linkPercentage > videoPercentage) {
              return "Unengaged Link Poster";
            }
            if (videoPercentage > imagePercentage && videoPercentage > textPercentage && videoPercentage > linkPercentage) {
              return "Unengaged Video Poster";
            }
            return "Unengaged Poster";
          }
          if (replyOtherPercentage >= 0.5) return "Reply Guy";
          if (stats.quoteOtherPercentage >= 0.5) return "Quote Guy";
          if (stats.repostOtherPercentage >= 0.5) return "Repost Guy";
      
          return "Unknown";
        }
      
        // Calculate social status (one label)
        function calculateSocialStatus({ ageInDays, followersCount, followsCount }) {
          const followPercentage = followersCount > 0 ? followsCount / followersCount : 0;
          if (ageInDays < 30) return "Newbie";
          if (followPercentage < 0.5) {
            if (followersCount >= 500 && followersCount < 10000) return "Micro Influencer";
            if (followersCount >= 10000 && followersCount < 100000) return "Influencer";
            if (followersCount >= 100000) return "Celebrity";
          }
          return "Community Member";
        }
      
        // Calculate activity status given rate (records per day)
        function calculateActivityStatus(rate) {
          if (rate === 0) return "inactive";
          if (rate > 0 && rate < 1) return "eepy";
          if (rate >= 1 && rate < 10) return "awake";
          if (rate >= 10) return "wired";
        }
      
        // Calculate profile completion: complete/incomplete/not started.
        function calculateProfileCompletion(profile) {
          const hasDisplayName = Boolean(profile.displayName && profile.displayName.trim());
          const hasBanner = Boolean(profile.banner && profile.banner.trim());
          const hasDescription = Boolean(profile.description && profile.description.trim());
          if (hasDisplayName && hasBanner && hasDescription) return "complete";
          if (hasDisplayName || hasBanner || hasDescription) return "incomplete";
          return "not started";
        }
      
        // Calculate domain rarity based on handle and its length.
        // For handles including "bsky.social", we count the entire string.
        // For custom domains:
        //   - If the handle ends with .com, .org, or .net, we use the domain part (after the first dot).
        //   - Otherwise, we use the entire string.
        function calculateDomainRarity(handle) {
          if (handle.includes("bsky.social")) {
            // For bsky handles, use the entire handle length.
            const len = handle.length;
            if (len >= 21) return "very common";
            if (len >= 18 && len <= 20) return "common";
            if (len === 17) return "uncommon";
            if (len === 16) return "rare";
            if (len === 15) return "very rare";
            if (len <= 14) return "extremely rare";
          } else {
            // For custom domains, check if the handle ends with one of the standard TLDs.
            const standardTLDs = [".com", ".org", ".net"];
            const hasStandardTLD = standardTLDs.some(tld => handle.endsWith(tld));
            let len;
            if (hasStandardTLD) {
              // Use only the domain part (e.g. everything after the first dot).
              const parts = handle.split(".");
              // Rejoin everything after the first element:
              const domain = parts.slice(1).join(".");
              len = domain.length;
              if (len >= 15) return "very common";
              if (len >= 12 && len <= 14) return "common";
              if (len >= 9 && len <= 11) return "uncommon";
              if (len >= 7 && len <= 8) return "rare";
              if (len === 6) return "very rare";
              if (len <= 5) return "extremely rare";
            } else {
              // Otherwise, use the entire handle.
              len = handle.length;
              if (len >= 14) return "very common";
              if (len >= 11 && len <= 13) return "common";
              if (len >= 8 && len <= 10) return "uncommon";
              if (len >= 6 && len <= 7) return "rare";
              if (len === 5) return "very rare";
              if (len <= 4) return "extremely rare";
            }
          }
          return "unknown";
        }
      
        // Calculate era based on createdAt date.
        function calculateEra(createdAt) {
          const created = new Date(createdAt);
          if (created >= new Date("2022-11-16") && created <= new Date("2023-01-31")) {
            return "pre-history";
          } else if (created >= new Date("2023-02-01") && created <= new Date("2024-01-31")) {
            return "invite-only";
          } else if (created > new Date("2024-01-31")) {
            return "public-release";
          }
          return "unknown";
        }
      
        // Calculate aggregate records for the account by iterating over each collection.
        async function calculateRecordsAggregate(collectionNames, ageInDays) {
          let totalRecords = 0;
          let totalBskyRecords = 0;
          let totalNonBskyRecords = 0;
          const collectionStats = {};
          for (const col of collectionNames) {
            const recs = await fetchRecordsForCollection(col);
            const count = recs.length;
            const perDay = ageInDays ? count / ageInDays : 0;
            collectionStats[col] = {
              count: roundToTwo(count),
              perDay: roundToTwo(perDay)
            };
            totalRecords += count;
            if (col.indexOf("app.bsky") !== -1) {
              totalBskyRecords += count;
            } else {
              totalNonBskyRecords += count;
            }
          }
          return { totalRecords, totalBskyRecords, totalNonBskyRecords, collectionStats };
        }
      
        // Calculate engagements for the account using the author feed.
        async function calculateEngagements() {
          const feed = await fetchAuthorFeed();
          let likesReceived = 0;
          let repostsReceived = 0;
          let quotesReceived = 0;
          let repliesReceived = 0;
      
          for (const item of feed) {
            if (item && item.post) {
              // Skip repost reasons
              if (JSON.stringify(item.post).includes("#reasonRepost")) continue;
      
              likesReceived += item.post.likeCount || 0;
              repostsReceived += item.post.repostCount || 0;
              quotesReceived += item.post.quoteCount || 0;
              repliesReceived += item.post.replyCount || 0;
            }
          }
      
          return {
            likesReceived: roundToTwo(likesReceived),
            repostsReceived: roundToTwo(repostsReceived),
            quotesReceived: roundToTwo(quotesReceived),
            repliesReceived: roundToTwo(repliesReceived),
          };
        }
      
        // Build the analysis narrative paragraphs based on the criteria.
        function buildAnalysisNarrative(accountData) {
          const { profile, activityAll, alsoKnownAs } = accountData;
          const { ageInDays, agePercentage } = calculateAge(profile.createdAt);
          let accountAgeStatement = "";
          if (agePercentage >= 0.97) {
            accountAgeStatement = "since the very beginning and is";
          } else if (agePercentage >= 0.7) {
            accountAgeStatement = "for a very long time and is";
          } else if (agePercentage >= 0.5) {
            accountAgeStatement = "for a long time and is";
          } else if (agePercentage >= 0.1) {
            accountAgeStatement = "for awhile and is";
          } else if (agePercentage >= 0.02) {
            accountAgeStatement = "for only a short period of time and is";
          } else {
            accountAgeStatement = "for barely any time at all";
          }
          const totalBskyCollections = activityAll.totalBskyCollections || 0;
          let blueskyFeatures = "";
          if (totalBskyCollections >= 12) {
            blueskyFeatures = "they are using all of Bluesky's core features";
          } else if (totalBskyCollections >= 8) {
            blueskyFeatures = "they are using most of Bluesky’s core features";
          } else if (totalBskyCollections >= 3) {
            blueskyFeatures = "they are using some of Bluesky’s core features";
          } else {
            blueskyFeatures = "they haven't used any of Bluesky's core features yet";
          }
          const totalNonBskyCollections = activityAll.totalNonBskyCollections || 0;
          const totalNonBskyRecords = activityAll.totalNonBskyRecords || 0;
          let atprotoEngagement = "";
          if (totalNonBskyCollections >= 10 && totalNonBskyRecords > 100) {
            atprotoEngagement = "is extremely engaged, having used many different services or tools";
          } else if (totalNonBskyCollections >= 5 && totalNonBskyRecords > 50) {
            atprotoEngagement = "is very engaged, having used many different services or tools";
          } else if (totalNonBskyCollections > 0 && totalNonBskyRecords > 5) {
            atprotoEngagement = "has dipped their toes in the water, but has yet to go deeper";
          } else {
            atprotoEngagement = "has not yet explored what's out there";
          }
          let domainHistoryStatement = "";
          if (alsoKnownAs.totalCustomAkas > 0 && profile.handle.includes("bsky.social")) {
            domainHistoryStatement = "They've used a custom domain name at some point but are currently using a default Bluesky handle";
          } else if (!profile.handle.includes("bsky.social")) {
            domainHistoryStatement = "They currently are using a custom domain";
          } else if (alsoKnownAs.totalAkas > 2 && !profile.handle.includes("bsky.social")) {
            domainHistoryStatement = "They have a custom domain set and have a history of using different aliases";
          } else {
            domainHistoryStatement = "They still have a default Bluesky handle";
          }
          let rotationKeyStatement = (accountData.rotationKeys === 2)
            ? "They don't have their own rotation key set"
            : "They have their own rotation key set";
          let pdsHostStatement = serviceEndpoint.includes("bsky.network")
            ? "their PDS is hosted by a Bluesky mushroom"
            : "their PDS is hosted by either a third-party or themselves";
      
          const narrative1 = `${profile.displayName} has been on the network ${accountAgeStatement} ${calculateActivityStatus(activityAll.totalRecordsPerDay)}. ` +
            `Their profile is ${calculateProfileCompletion(profile)}, and ${blueskyFeatures}. ` +
            `When it comes to the broader AT Proto ecosystem, this identity ${atprotoEngagement}. ` +
            `${domainHistoryStatement} which is ${calculateDomainRarity(profile.handle)}. ` +
            `${rotationKeyStatement}, and ${pdsHostStatement}.`;
      
          const era = calculateEra(profile.createdAt);
          const postingStyle = accountData.postingStyle;
          const socialStatus = accountData.socialStatus;
          const mediaType = "a mix of text, images, and video";
          const followRatio = profile.followersCount > 0 
            ? roundToTwo(profile.followsCount / profile.followersCount) 
            : 0;
          const narrative2 = `${profile.displayName} first joined Bluesky during the ${era} era. ` +
            `Their style of posting is "${postingStyle}". ` +
            `Their posts consist of ${mediaType}. ` +
            `They are ${socialStatus} as is indicated by their follower count of ${profile.followersCount} and their follower/following ratio of ${followRatio}.`;
      
          return narrative1 + "\n\n" + narrative2;
        }
      
        /***********************************************************************
         * Main Function – Build accountData and final JSON object.
         ***********************************************************************/
        async function loadAccountData() {
          try {
            // 1. Get basic profile (and use it for several fields)
            const profile = await fetchProfile();
      
            // 2. Age details
            const { ageInDays, agePercentage } = calculateAge(profile.createdAt);
      
            // 3. Blobs count and per-day/post calculations
            const blobsCount = await fetchAllBlobsCount();
      
            // 4. Repo description gives collections.
            const repoDescription = await fetchRepoDescription();
            let collections = repoDescription.collections || [];
            const totalCollections = collections.length;
            const bskyCollectionNames = collections.filter(col => col.indexOf("app.bsky") !== -1);
            const totalBskyCollections = bskyCollectionNames.length;
            const totalNonBskyCollections = totalCollections - totalBskyCollections;
            
            // 5. Build targetCollections array (includes all collections)
            const targetCollections = [...new Set(collections)];
      
            // 6. Aggregate record counts.
            const { totalRecords, totalBskyRecords, totalNonBskyRecords, collectionStats } = await calculateRecordsAggregate(targetCollections, ageInDays);
            const totalRecordsPerDay = ageInDays ? totalRecords / ageInDays : 0;
            const totalBskyRecordsPerDay = ageInDays ? totalBskyRecords / ageInDays : 0;
            const totalNonBskyRecordsPerDay = ageInDays ? totalNonBskyRecords / ageInDays : 0;
            const totalBskyRecordsPercentage = totalRecords ? totalBskyRecords / totalRecords : 0;
            const totalNonBskyRecordsPercentage = totalRecords ? totalNonBskyRecords / totalRecords : 0;
      
            // 7. For detailed post statistics.
            const postsRecords = await fetchRecordsForCollection("app.bsky.feed.post");
            const postsCount = profile.postsCount || postsRecords.length;
            function filterRecords(records, testFunc) {
              return records.filter(testFunc).length;
            }
            // Count only posts (records with no "reply" key).
            const onlyPosts = filterRecords(postsRecords, rec => !rec.value.hasOwnProperty("reply"));
            const onlyPostsPerDay = ageInDays ? onlyPosts / ageInDays : 0;
            // Count replies (records with a "reply" key).
            const onlyReplies = filterRecords(postsRecords, rec => rec.value.hasOwnProperty("reply"));
            const onlyRepliesPerDay = ageInDays ? onlyReplies / ageInDays : 0;
            
            // New logic for replies.
            const onlyRepliesToSelf = postsRecords.filter(rec => {
              // Check if the "reply" object exists in the "value" field
              if (!rec.value || !rec.value.reply || !rec.value.reply.parent) return false;
      
              // Check if the "parent" object has a "uri" and if it contains the DID
              return rec.value.reply.parent.uri.includes(did);
              }).length;
            const onlyRepliesToSelfPerDay = ageInDays ? onlyRepliesToSelf / ageInDays : 0;
            const onlyRepliesToOthers = onlyReplies - onlyRepliesToSelf;
            const onlyRepliesToOthersPerDay = ageInDays ? onlyRepliesToOthers / ageInDays : 0;
      
            // Count quotes.
            const onlyQuotes = filterRecords(postsRecords, rec => rec.value.embed && rec.value.embed["$type"] === "app.bsky.embed.record");
            const onlyQuotesPerDay = ageInDays ? onlyQuotes / ageInDays : 0;
            const onlySelfQuotes = filterRecords(postsRecords, rec => {
              // Check if the "embed" object exists and is of the correct type
              if (
                  !rec.value || 
                  !rec.value.embed || 
                  (rec.value.embed["$type"] !== "app.bsky.embed.record" && rec.value.embed["$type"] !== "app.bsky.embed.recordWithMedia")
              ) {
                  return false;
              }
      
              // Match either `record.record.uri` or `record.uri` containing the DID
              const embedRecord = rec.value.embed.record;
              return (
                  (embedRecord.record && embedRecord.record.uri && embedRecord.record.uri.includes(did)) ||
                  (embedRecord.uri && embedRecord.uri.includes(did))
              );
              });
            const onlySelfQuotesPerDay = ageInDays ? onlySelfQuotes / ageInDays : 0;
            const onlyOtherQuotes = onlyQuotes - onlySelfQuotes;
            const onlyOtherQuotesPerDay = ageInDays ? onlyOtherQuotes / ageInDays : 0;
      
            // Count reposts.
            const repostRecords = await fetchRecordsForCollection("app.bsky.feed.repost");
            const onlyReposts = repostRecords.length;
            const onlyRepostsPerDay = ageInDays ? onlyReposts / ageInDays : 0;
            const onlySelfReposts = filterRecords(repostRecords, rec => {
              // Ensure the "subject" object and "uri" property exist
              if (!rec.value || !rec.value.subject || !rec.value.subject.uri) return false;
      
              // Check if the "uri" contains the DID
              return rec.value.subject.uri.includes(did);
              });
            const onlySelfRepostsPerDay = ageInDays ? onlySelfReposts / ageInDays : 0;
            const onlyOtherReposts = onlyReposts - onlySelfReposts;
            const onlyOtherRepostsPerDay = ageInDays ? onlyOtherReposts / ageInDays : 0;
      
            // Count posts with images.
            const postsWithImages = filterRecords(postsRecords, rec => rec.value.embed && rec.value.embed["$type"] === "app.bsky.embed.images");
            const imagePostsPerDay = ageInDays ? postsWithImages / ageInDays : 0;
            const imagePostsAltText = filterRecords(postsRecords, rec => {
              // Check if the embed object exists and is of the correct type
              if (!rec.value.embed || rec.value.embed["$type"] !== "app.bsky.embed.images") {
                  return false;
              }
      
              // Check if any image in the images array contains an "alt" value
              return rec.value.embed.images && rec.value.embed.images.some(image => image.alt && image.alt.trim());
              });
            const imagePostsNoAltText = postsWithImages - imagePostsAltText;
            const altTextPercentage = postsWithImages ? imagePostsAltText / postsWithImages : 0;
            // Count posts with only text.
            const postsWithOnlyText = filterRecords(postsRecords, rec =>
              !rec.value.embed && !rec.value.reply && !(rec.value.facets && JSON.stringify(rec.value.facets).indexOf("app.bsky.richtext.facet#link") !== -1)
            );
            const textPostsPerDay = ageInDays ? postsWithOnlyText / ageInDays : 0;
              // Count posts with mentions.
              const postsWithMentions = filterRecords(postsRecords, rec => {
              if (!rec.value || !rec.value.facets) return false;
      
              return rec.value.facets.some(facet =>
                  facet.features && facet.features.some(feature => feature["$type"] === "app.bsky.richtext.facet#mention")
              );
              });
            const mentionPostsPerDay = ageInDays ? postsWithMentions / ageInDays : 0;
            // Count posts with video.
            const postsWithVideo = filterRecords(postsRecords, rec => rec.value.embed && rec.value.embed["$type"] === "app.bsky.embed.video");
            const videoPostsPerDay = ageInDays ? postsWithVideo / ageInDays : 0;
            // Count posts with links.
            const postsWithLinks = filterRecords(postsRecords, rec => {
              if (rec.value.facets && rec.value.facets.features && rec.value.facets.features.some(f => f["$type"] === "app.bsky.richtext.facet#link")) return true;
              if (rec.value.embed && rec.value.embed["$type"] === "app.bsky.embed.external") return true;
              return false;
            });
            const linkPostsPerDay = ageInDays ? postsWithLinks / ageInDays : 0;
      
            const postStats = {
              postsCount: roundToTwo(postsCount),
              postsPerDay: ageInDays ? roundToTwo(postsCount / ageInDays) : 0,
              onlyPosts: roundToTwo(onlyPosts),
              onlyPostsPerDay: ageInDays ? roundToTwo(onlyPosts / ageInDays) : 0,
              onlyReplies: roundToTwo(onlyReplies),
              onlyRepliesPerDay: ageInDays ? roundToTwo(onlyReplies / ageInDays) : 0,
              onlyRepliesToSelf: roundToTwo(onlyRepliesToSelf),
              onlyRepliesToSelfPerDay: ageInDays ? roundToTwo(onlyRepliesToSelf / ageInDays) : 0,
              onlyRepliesToOthers: roundToTwo(onlyRepliesToOthers),
              onlyRepliesToOthersPerDay: ageInDays ? roundToTwo(onlyRepliesToOthers / ageInDays) : 0,
              onlyQuotes: roundToTwo(onlyQuotes),
              onlyQuotesPerDay: ageInDays ? roundToTwo(onlyQuotes / ageInDays) : 0,
              onlySelfQuotes: roundToTwo(onlySelfQuotes),
              onlySelfQuotesPerDay: ageInDays ? roundToTwo(onlySelfQuotes / ageInDays) : 0,
              onlyOtherQuotes: roundToTwo(onlyOtherQuotes),
              onlyOtherQuotesPerDay: ageInDays ? roundToTwo(onlyOtherQuotes / ageInDays) : 0,
              onlyReposts: roundToTwo(onlyReposts),
              onlyRepostsPerDay: ageInDays ? roundToTwo(onlyReposts / ageInDays) : 0,
              onlySelfReposts: roundToTwo(onlySelfReposts),
              onlySelfRepostsPerDay: ageInDays ? roundToTwo(onlySelfReposts / ageInDays) : 0,
              onlyOtherReposts: roundToTwo(onlyOtherReposts),
              onlyOtherRepostsPerDay: ageInDays ? roundToTwo(onlyOtherReposts / ageInDays) : 0,
              postsWithImages: roundToTwo(postsWithImages),
              imagePostsPerDay: ageInDays ? roundToTwo(postsWithImages / ageInDays) : 0,
              imagePostsAltText: roundToTwo(imagePostsAltText),
              imagePostsNoAltText: roundToTwo(imagePostsNoAltText),
              altTextPercentage: roundToTwo(altTextPercentage),
              postsWithOnlyText: roundToTwo(postsWithOnlyText),
              textPostsPerDay: ageInDays ? roundToTwo(postsWithOnlyText / ageInDays) : 0,
              postsWithMentions: roundToTwo(postsWithMentions),
              mentionPostsPerDay: ageInDays ? roundToTwo(postsWithMentions / ageInDays) : 0,
              postsWithVideo: roundToTwo(postsWithVideo),
              videoPostsPerDay: ageInDays ? roundToTwo(postsWithVideo / ageInDays) : 0,
              postsWithLinks: roundToTwo(postsWithLinks),
              linkPostsPerDay: ageInDays ? roundToTwo(postsWithLinks / ageInDays) : 0,
              replyPercentage: postsCount ? roundToTwo(onlyReplies / postsCount) : 0,
              replySelfPercentage: postsCount ? roundToTwo(onlyRepliesToSelf / postsCount) : 0,
              replyOtherPercentage: postsCount ? roundToTwo(onlyRepliesToOthers / postsCount) : 0,
              quotePercentage: postsCount ? roundToTwo(onlyQuotes / postsCount) : 0,
              quoteSelfPercentage: postsCount ? roundToTwo(onlySelfQuotes / postsCount) : 0,
              quoteOtherPercentage: postsCount ? roundToTwo(onlyOtherQuotes / postsCount) : 0,
              repostPercentage: postsCount ? roundToTwo(onlyReposts / postsCount) : 0,
              repostSelfPercentage: postsCount ? roundToTwo(onlySelfReposts / postsCount) : 0,
              repostOtherPercentage: postsCount ? roundToTwo(onlyOtherReposts / postsCount) : 0,
              textPercentage: postsCount ? roundToTwo(postsWithOnlyText / postsCount) : 0,
              linkPercentage: postsCount ? roundToTwo(postsWithLinks / postsCount) : 0,
              imagePercentage: postsCount ? roundToTwo(postsWithImages / postsCount) : 0,
              videoPercentage: postsCount ? roundToTwo(postsWithVideo / postsCount) : 0,
              totalBskyRecordsPerDay: roundToTwo(totalBskyRecordsPerDay),
              totalNonBskyRecordsPerDay: roundToTwo(totalNonBskyRecordsPerDay),
            };
      
            // 8. Parse audit log for rotation keys and alsoKnownAs information.
            const rawAuditData = await fetchAuditLog();
            let auditRecords = Array.isArray(rawAuditData) ? rawAuditData : Object.values(rawAuditData);
            const plcOperations = auditRecords.length;
            let rotationKeys = 0;
            let activeAkas = 0;
            let akaSet = new Set();
      
            if (plcOperations > 0) {
              auditRecords.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
              const latestRecord = auditRecords[auditRecords.length - 1];
              if (latestRecord.operation && Array.isArray(latestRecord.operation.rotationKeys)) {
                rotationKeys = latestRecord.operation.rotationKeys.length;
              }
              if (latestRecord.operation && Array.isArray(latestRecord.operation.alsoKnownAs)) {
                activeAkas = latestRecord.operation.alsoKnownAs.length;
              }
              auditRecords.forEach(record => {
                if (record.operation && Array.isArray(record.operation.alsoKnownAs)) {
                  record.operation.alsoKnownAs.forEach(alias => {
                    akaSet.add(alias);
                  });
                }
              });
            }
            const totalAkas = akaSet.size;
            const totalBskyAkas = Array.from(akaSet).filter(alias => alias.includes("bsky.social")).length;
            const totalCustomAkas = roundToTwo(totalAkas - totalBskyAkas);
            const rotationKeysRounded = roundToTwo(rotationKeys);
            const activeAkasRounded = roundToTwo(activeAkas);
      
            // 9. Compute engagements from author feed.
            const engagementsReceived = await calculateEngagements();
      
            // 10. Compute overall activity statuses.
            const overallActivityStatus = calculateActivityStatus(totalRecordsPerDay);
            const bskyActivityStatus = calculateActivityStatus(totalBskyRecordsPerDay);
            const atprotoActivityStatus = calculateActivityStatus(totalNonBskyRecordsPerDay);
      
            // 11. Compute posting style.
            const postingStyle = calculatePostingStyle({
              ...postStats,
              totalBskyRecordsPerDay
            });
      
            // 12. Compute social status.
            const socialStatus = calculateSocialStatus({
              ageInDays,
              followersCount: profile.followersCount || 0,
              followsCount: profile.followsCount || 0
            });
      
            // 13. Build analysis narrative paragraphs.
            const narrative = buildAnalysisNarrative({
              profile,
              activityAll: {
                totalRecords,
                totalRecordsPerDay,
                totalBskyCollections,
                totalNonBskyCollections,
                totalBskyRecords,
                totalBskyRecordsPerDay,
                totalBskyRecordsPercentage,
                totalNonBskyRecords,
                totalNonBskyRecordsPerDay,
                totalNonBskyRecordsPercentage,
              },
              postingStyle,
              socialStatus,
              alsoKnownAs: {
                totalAkas,
                totalCustomAkas,
                totalBskyAkas
              }
            });
      
            // 14. Construct final accountData JSON.
            const accountData = {
              profile: {
                ...profile,
                did: profile.did || did
              },
              displayName: profile.displayName,
              handle: profile.handle,
              did: profile.did || did,
              profileEditedDate: profile.indexedAt,
              profileCompletion: calculateProfileCompletion(profile),
              scoreGeneratedAt: new Date().toISOString(),
              serviceEndpoint,
              pdsType: serviceEndpoint.includes("bsky.network") ? "Bluesky" : "Third-party",
              createdAt: profile.createdAt,
              ageInDays: roundToTwo(ageInDays),
              agePercentage: roundToTwo(agePercentage),
              blobsCount: roundToTwo(blobsCount),
              blobsPerDay: ageInDays ? roundToTwo(blobsCount / ageInDays) : 0,
              blobsPerPost: postsCount ? roundToTwo(blobsCount / postsCount) : 0,
              blobsPerImagePost: postsWithImages ? roundToTwo(blobsCount / postsWithImages) : 0,
              followersCount: roundToTwo(profile.followersCount),
              followsCount: roundToTwo(profile.followsCount),
              followPercentage: profile.followersCount ? roundToTwo(profile.followsCount / profile.followersCount) : 0,
              postsCount: roundToTwo(postsCount),
              rotationKeys: rotationKeysRounded,
              era: calculateEra(profile.createdAt),
              postingStyle,
              socialStatus,
              activityAll: {
                activityStatus: overallActivityStatus,
                bskyActivityStatus,
                atprotoActivityStatus,
                totalCollections: roundToTwo(totalCollections),
                totalBskyCollections: roundToTwo(totalBskyCollections),
                totalNonBskyCollections: roundToTwo(totalNonBskyCollections),
                totalRecords: roundToTwo(totalRecords),
                totalRecordsPerDay: roundToTwo(totalRecordsPerDay),
                totalBskyRecords: roundToTwo(totalBskyRecords),
                totalBskyRecordsPerDay: roundToTwo(totalBskyRecordsPerDay),
                totalBskyRecordsPercentage: roundToTwo(totalBskyRecordsPercentage),
                totalNonBskyRecords: roundToTwo(totalNonBskyRecords),
                totalNonBskyRecordsPerDay: roundToTwo(totalNonBskyRecordsPerDay),
                totalNonBskyRecordsPercentage: roundToTwo(totalNonBskyRecordsPercentage),
                plcOperations: roundToTwo(plcOperations),
                // Dynamic collections
                ...collectionStats,
                // Existing specific collections (if you still want to keep them)
                "app.bsky.feed.post": {
                  ...postStats,
                  engagementsReceived
                },
                // Additional hard-coded collections can be added here if needed
              },
              activityLast30Days: {
                profileEdited: (new Date(profile.indexedAt) > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000))
              },
              alsoKnownAs: {
                totalAkas: roundToTwo(totalAkas),
                activeAkas: activeAkasRounded,
                totalBskyAkas: roundToTwo(totalBskyAkas),
                totalCustomAkas: roundToTwo(totalCustomAkas),
                domainRarity: calculateDomainRarity(profile.handle),
                handleType: profile.handle.includes("bsky.social") ? "default" : "custom"
              },
              analysis: {
                narrative: narrative
              }
            };
      
            // 15. Build final output JSON.
            const finalOutput = {
              message: "accountData retrieved successfully",
              accountData
            };
      
            // Round all numerical values in accountData
            const roundedAccountData = roundNumbers(finalOutput);
      
            // Render plain JSON in the <pre> element
            document.getElementById("output").textContent = JSON.stringify(roundedAccountData, null, 2);
      
            // Initialize JSONEditor and render the pretty JSON
            const container = document.getElementById("jsoneditor");
            const options = {
              mode: 'tree',
              indentation: 2,
              onError: function (err) {
                alert(err.toString());
              },
              onModeChange: function (newMode, oldMode) {
                console.log('Mode switched from', oldMode, 'to', newMode);
              }
            };
            const editor = new JSONEditor(container, options);
            editor.set(roundedAccountData);
      
          } catch (err) {
            console.error("Error loading account data:", err);
            const errorOutput = {
              message: "Error retrieving accountData",
              error: err.toString()
            };
            // Render plain error JSON
            document.getElementById("output").textContent = JSON.stringify(errorOutput, null, 2);
            
            // Initialize JSONEditor with error JSON
            const container = document.getElementById("jsoneditor");
            const options = {
              mode: 'tree',
              indentation: 2
            };
            const editor = new JSONEditor(container, options);
            editor.set(errorOutput);
          }
        }
      
        // Run when page loads.
        loadAccountData();
        </script>
      </div>
  </main>

  <!-- Footer -->
  <div id="footer"></div>

  <script src="js/main.js"></script>
</body>
</html>
