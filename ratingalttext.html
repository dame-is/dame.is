<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="images/favicon.ico" type="image/x-icon" />
  <title>Alt Text Rating</title>
  <script src="https://kit.fontawesome.com/830b363cf0.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="/css/styles.css" />
  <style>
    /* Hide results until needed */
    #results {
      display: none;
    }
    /* Responsive container for the gauge */
    .gauge-container {
      margin: 20px auto;
      width: 100%;
      max-width: 400px;
      position: relative;
      padding-bottom: 0;
      margin-top: 0px;
      margin-bottom: 6px;
    }
    .gauge-container svg {
      position: relative;
      top: -13px;
      left: 0;
      width: 100%;
      margin-top: -93px;
      overflow: hidden;
    }
    /* Smooth transition for needle rotation */
    .needle-group {
      transition: transform 0.2s linear;
    }
    /* Style for the checkbox and label */
    .checkbox-container {
      display: inline-flex;
      align-items: center;
      margin-left: 10px;
    }
    .checkbox-container input {
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <!-- Navigation -->
  <div id="nav"></div>

  <!-- Main Content -->
  <main>
    <div id="alt-text-rating-form" class="alt-card">
      <h1>Bluesky Alt Text Rating</h1>
      <p>How consistently do you use alt text?</p>
      <form class="search-bar" id="search-form">
        <!-- The search input -->
        <input type="text" id="username" placeholder="(e.g., dame.bsky.social)" required />

        <!-- Row with the Analyze button -->
        <div class="action-row">
          <button type="submit">Analyze</button>
        </div>
      </form>
      <!-- Results container -->
      <div class="results" id="results">
        <p id="textResults"></p>
        <!-- Responsive gauge container -->
        <div class="gauge-container">
          <!-- SVG gauge with viewBox="0 0 400 300" -->
          <svg class="gauge-svg" viewBox="0 0 400 300">
            <!-- Quadrants for the gauge -->
            <path d="M50,300 A150,150 0 0,1 93.93,193.93 L200,300 Z" fill="#ff0000" />
            <path d="M93.93,193.93 A150,150 0 0,1 200,150 L200,300 Z" fill="#ff9900" />
            <path d="M200,150 A150,150 0 0,1 306.07,193.93 L200,300 Z" fill="#ffff66" />
            <path d="M306.07,193.93 A150,150 0 0,1 350,300 L200,300 Z" fill="#00cc00" />
            <!-- Center pivot circle -->
            <circle cx="200" cy="300" r="10" fill="#000" />
            <!-- Needle group with pivot at (200,300) -->
            <g id="needle-group" class="needle-group" transform="rotate(0,200,300)">
              <!-- Needle from (200,300) to (50,300) -->
              <line id="needle" x1="200" y1="300" x2="50" y2="300" stroke="#000" stroke-width="7" />
            </g>
          </svg>
        </div>
        <!-- Custom Checkbox -->
        <label class="custom-checkbox">
          <input type="checkbox" id="last90days" />
          <span class="checkbox-indicator"></span>
          Last 90 Days Only
        </label>
        <p>
          <a href="https://bsky.app/profile/cred.blue" target="_blank">
            Discover more tools: @cred.blue
          </a>
        </p>
      </div>
    </div>
    <!-- Extra info card (always visible) -->
    <div id="extra-info" class="alt-card">
      <div class="resources">
        <h3>Learn more about alt text:</h3>
        <ul>
          <li>
            <a href="https://bsky.app/settings/accessibility" target="_blank">
              Change your Bluesky alt text settings
            </a>
          </li>
          <li>
            <a href="https://www.section508.gov/create/alternative-text/" target="_blank">
              Authoring Meaningful Alternative Text
            </a>
          </li>
          <li>
            <a href="https://accessibility.huit.harvard.edu/describe-content-images" target="_blank">
              Write helpful Alt Text to describe images
            </a>
          </li>
        </ul>
      </div>
    </div>

    <script>
      // ----------------------------
      // Analysis Functions
      // ----------------------------
      const PUBLIC_API_URL = "https://public.api.bsky.app";
      const emojis = ["☹️", "😐", "🙂", "☺️"];

      // Global storage for records so we can re-run the analysis based on checkbox changes.
      let allRecords = [];

      async function resolveHandleToDID(handle) {
        try {
          const res = await fetch(
            `${PUBLIC_API_URL}/xrpc/com.atproto.identity.resolveHandle?handle=${encodeURIComponent(handle)}`
          );
          const data = await res.json();
          if (data.did) return data.did;
          throw new Error(`Invalid username, please try again!`);
        } catch (error) {
          console.error("Error resolving handle to DID:", error);
          throw error;
        }
      }

      async function fetchServiceEndpoint(did) {
        try {
          const res = await fetch(`https://plc.directory/${did}`);
          const data = await res.json();
          if (data.service && data.service.length > 0) {
            const serviceEndpoint = data.service[0].serviceEndpoint;
            if (serviceEndpoint) return serviceEndpoint;
          }
          throw new Error(`Service endpoint not found for DID: ${did}`);
        } catch (error) {
          console.error("Error fetching service endpoint:", error);
          throw error;
        }
      }

      async function fetchRecordsForCollection(serviceEndpoint, did, collectionName) {
        let urlBase = `${serviceEndpoint}/xrpc/com.atproto.repo.listRecords?repo=${encodeURIComponent(
          did
        )}&collection=${encodeURIComponent(collectionName)}&limit=100`;
        let records = [];
        let cursor = null;
        do {
          const url = cursor ? `${urlBase}&cursor=${cursor}` : urlBase;
          const res = await fetch(url);
          const data = await res.json();
          if (Array.isArray(data.records)) {
            records = records.concat(data.records);
          }
          cursor = data.cursor || null;
        } while (cursor);
        return records;
      }

      /**
       * Analyze posts with an option to filter to only the last 90 days.
       *
       * @param {Array} records - The array of post records.
       * @param {boolean} useLast90Days - If true, filter posts to those created in the last 90 days.
       * @returns {Object} analysis results.
       */
      function analyzePosts(records, useLast90Days) {
        // Determine the minimum date for filtering
        let minDate;
        if (useLast90Days) {
          minDate = new Date();
          minDate.setDate(minDate.getDate() - 90);
        } else {
          // If not filtering, set minDate to a very early date
          minDate = new Date("1970-01-01T00:00:00Z");
        }

        // Filter by createdAt using the determined minDate
        const filteredRecords = records.filter((rec) => {
          if (rec.value.createdAt) {
            const postDate = new Date(rec.value.createdAt);
            return postDate >= minDate;
          }
          return false;
        });
        const postsWithImages = filteredRecords.filter(
          (rec) =>
            rec.value.embed && rec.value.embed["$type"] === "app.bsky.embed.images"
        );
        const postsWithAltText = postsWithImages.filter((rec) =>
          rec.value.embed.images.some((img) => img.alt && img.alt.trim())
        );
        const imageReplies = filteredRecords.filter(
          (rec) =>
            rec.value.embed &&
            rec.value.embed["$type"] === "app.bsky.embed.images" &&
            rec.value.reply
        );
        const altTextPercentage =
          (postsWithAltText.length / postsWithImages.length) * 100 || 0;
        let emoji = emojis[0];
        if (altTextPercentage >= 75) {
          emoji = emojis[3];
        } else if (altTextPercentage >= 50) {
          emoji = emojis[2];
        } else if (altTextPercentage >= 25) {
          emoji = emojis[1];
        }
        return {
          totalPosts: filteredRecords.length,
          postsWithImages: postsWithImages.length,
          postsWithAltText: postsWithAltText.length,
          imageReplies: imageReplies.length,
          altTextPercentage: altTextPercentage,
          emoji: emoji,
        };
      }

      // ----------------------------
      // Needle Oscillation Settings and Animation (using requestAnimationFrame)
      // ----------------------------
      // You can adjust these parameters for speed and bounce behavior
      let baseSpeed = 0.15; // Base speed in percentage change per millisecond
      let oscillationMin = 10; // Minimum percentage value
      let oscillationMax = 90; // Maximum percentage value
      let bounceRange = 40; // Maximum random bounce in percentage
      let currentOscillation = oscillationMin;
      let oscillationDirection = 1; // 1 for increasing, -1 for decreasing
      let animFrameId = null;
      let lastTimestamp = null;

      function animateNeedle(timestamp) {
        if (!lastTimestamp) {
          lastTimestamp = timestamp;
        }
        const deltaTime = timestamp - lastTimestamp;
        lastTimestamp = timestamp;

        // Calculate increment based on base speed and a random factor for natural variation
        let randomFactor = 0.8 + Math.random() * 0.4; // between 0.8 and 1.2
        let increment = baseSpeed * deltaTime * randomFactor;
        currentOscillation += oscillationDirection * increment;

        // Bounce logic: when reaching a bound, reverse direction and add a random bounce offset
        if (currentOscillation >= oscillationMax) {
          currentOscillation = oscillationMax - Math.random() * bounceRange;
          oscillationDirection = -1;
        } else if (currentOscillation <= oscillationMin) {
          currentOscillation = oscillationMin + Math.random() * bounceRange;
          oscillationDirection = 1;
        }

        updateGauge(currentOscillation);
        animFrameId = requestAnimationFrame(animateNeedle);
      }

      function startNeedleAnimation() {
        // Reset state variables
        currentOscillation = oscillationMin;
        oscillationDirection = 1;
        lastTimestamp = null;
        // Cancel any existing animation frame
        if (animFrameId) {
          cancelAnimationFrame(animFrameId);
        }
        // Start the animation loop
        animFrameId = requestAnimationFrame(animateNeedle);
      }

      function stopNeedleAnimation() {
        if (animFrameId) {
          cancelAnimationFrame(animFrameId);
          animFrameId = null;
        }
      }

      /**
       * Updates the gauge needle based on the given percentage.
       * Mapping: 0% → 0° (fully left), 100% → 180° (fully right)
       *
       * @param {number} percentage - A value between 0 and 100.
       */
      function updateGauge(percentage) {
        percentage = Math.max(0, Math.min(100, percentage));
        const angleDeg = (percentage / 100) * 180;
        const needleGroup = document.getElementById("needle-group");
        if (needleGroup) {
          needleGroup.setAttribute("transform", `rotate(${angleDeg},200,300)`);
        } else {
          console.error("Needle group element not found.");
        }
      }

      // Helper function for proper pluralization of result strings.
      function pluralize(count, singular, plural) {
        return count === 1 ? `${count} ${singular}` : `${count} ${plural}`;
      }

      // ----------------------------
      // Function to update the analysis results based on the checkbox state.
      // ----------------------------
      function updateAnalysisResults(useLast90Days) {
        // Re-run analysis on the globally stored records
        const analysis = analyzePosts(allRecords, useLast90Days);
        const textResults = document.getElementById("textResults");
        const scoreText =
          analysis.postsWithImages === 0
            ? "No image posts detected! 🔍"
            : `${analysis.altTextPercentage.toFixed(2)}% ${analysis.emoji}`;

        textResults.innerHTML = `
          <p>${pluralize(analysis.totalPosts, "post analyzed", "posts analyzed")}</p>
          <p>${pluralize(analysis.postsWithImages, "contains images", "contain images")}</p>
          <p>${pluralize(analysis.imageReplies, "is a reply", "are replies")}</p>
          <p>${pluralize(analysis.postsWithAltText, "post has alt text", "posts have alt text")}</p>
          <h2>Score: ${scoreText}</h2>
        `;

        // Set the gauge needle to the final percentage
        updateGauge(analysis.altTextPercentage);
      }

      // ----------------------------
      // Form Handler
      // ----------------------------
      document.getElementById("search-form").addEventListener("submit", async (event) => {
        event.preventDefault();
        const username = document.getElementById("username").value.trim();
        const resultsDiv = document.getElementById("results");
        const textResults = document.getElementById("textResults");
        // Show the results area (which will display either results or error)
        resultsDiv.style.display = "block";
        // Ensure the gauge container is visible on a successful run
        document.querySelector(".gauge-container").style.display = "block";
        textResults.textContent = "Loading...";
        // Start needle animation while loading
        startNeedleAnimation();

        try {
          const did = await resolveHandleToDID(username);
          const serviceEndpoint = await fetchServiceEndpoint(did);
          allRecords = await fetchRecordsForCollection(serviceEndpoint, did, "app.bsky.feed.post");

          // Check if the "Last 90 Days" checkbox is checked
          const useLast90Days = document.getElementById("last90days").checked;
          const analysis = analyzePosts(allRecords, useLast90Days);
          const scoreText =
            analysis.postsWithImages === 0
              ? "No image posts detected! 🔍"
              : `${analysis.altTextPercentage.toFixed(2)}% ${analysis.emoji}`;

          textResults.innerHTML = `
            <p>${pluralize(analysis.totalPosts, "post analyzed", "posts analyzed")}</p>
            <p>${pluralize(analysis.postsWithImages, "contains images", "contain images")}</p>
            <p>${pluralize(analysis.imageReplies, "is a reply", "are replies")}</p>
            <p>${pluralize(analysis.postsWithAltText, "post has alt text", "posts have alt text")}</p>
            <h2>Score: ${scoreText}</h2>
          `;

          stopNeedleAnimation();
          updateGauge(analysis.altTextPercentage);
        } catch (error) {
          // Stop the needle animation and reset the gauge
          stopNeedleAnimation();
          updateGauge(oscillationMin);
          // Clear stored records
          allRecords = [];
          // Hide the gauge container on error so it does not appear
          document.querySelector(".gauge-container").style.display = "none";
          // Display the error message (with red text) in the results area
          textResults.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
          // Set focus back to the username input so the user can try again
          document.getElementById("username").focus();
        }
      });

      // ----------------------------
      // Listen for checkbox state changes
      // ----------------------------
      document.getElementById("last90days").addEventListener("change", (event) => {
        // Only update if we have already fetched records
        if (allRecords.length > 0) {
          const useLast90Days = event.target.checked;
          updateAnalysisResults(useLast90Days);
        }
      });
    </script>
  </main>

  <!-- Footer -->
  <div id="footer"></div>
  <script src="js/main.js"></script>
</body>
</html>
