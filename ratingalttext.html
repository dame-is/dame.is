<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="images/favicon.ico" type="image/x-icon">
  <title>Alt Text Rating</title>
  <script src="https://kit.fontawesome.com/830b363cf0.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="/css/styles.css">
  <style>
    /* Simple styling for card separation; adjust as needed */
    .alt-card {
      background: #fff;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    /* Hide results div by default */
    #results {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Navigation -->
  <div id="nav"></div>

  <!-- Main Content -->
  <main>
    <div id="alt-text-rating-form" class="alt-card">
      <h1>Bluesky Alt Text Rating</h1>
      <form class="search-bar" id="search-form">
        <input type="text" id="username" placeholder="(e.g., dame.bsky.social)" required />
        <button type="submit">Analyze</button>
      </form>
      <!-- This card will hold the analysis results -->
      <div class="results" id="results"></div>
    </div>
    <!-- Extra info card always visible -->
    <div id="extra-info" class="alt-card">
      <div class="resources">
        <h3>Learn more about alt text:</h3>
        <ul>
          <li><a href="https://bsky.app/settings/accessibility" target="_blank">Change your Bluesky alt text settings</a></li>
          <li><a href="https://www.section508.gov/create/alternative-text/" target="_blank">Authoring Meaningful Alternative Text</a></li>
          <li><a href="https://accessibility.huit.harvard.edu/describe-content-images" target="_blank">Write helpful Alt Text to describe images</a></li>
        </ul>
      </div>
    </div>

    <script>
      const PUBLIC_API_URL = "https://public.api.bsky.app";
      const emojis = ["‚òπÔ∏è", "üòê", "üôÇ", "‚ò∫Ô∏è"];
      // Define the minimum date (posts on or after this date will be counted)
      const MIN_DATE = new Date("2022-11-16T00:00:00Z");

      async function resolveHandleToDID(handle) {
        try {
          const res = await fetch(`${PUBLIC_API_URL}/xrpc/com.atproto.identity.resolveHandle?handle=${encodeURIComponent(handle)}`);
          const data = await res.json();
          if (data.did) return data.did;
          throw new Error(`Unable to resolve DID for handle: ${handle}`);
        } catch (error) {
          console.error('Error resolving handle to DID:', error);
          throw error;
        }
      }

      async function fetchServiceEndpoint(did) {
        try {
          const res = await fetch(`https://plc.directory/${did}`);
          const data = await res.json();
          if (data.service && data.service.length > 0) {
            const serviceEndpoint = data.service[0].serviceEndpoint;
            if (serviceEndpoint) return serviceEndpoint;
          }
          throw new Error(`Service endpoint not found for DID: ${did}`);
        } catch (error) {
          console.error('Error fetching service endpoint:', error);
          throw error;
        }
      }

      async function fetchRecordsForCollection(serviceEndpoint, did, collectionName) {
        let urlBase = `${serviceEndpoint}/xrpc/com.atproto.repo.listRecords?repo=${encodeURIComponent(did)}&collection=${encodeURIComponent(collectionName)}&limit=100`;
        let records = [];
        let cursor = null;

        do {
          const url = cursor ? `${urlBase}&cursor=${cursor}` : urlBase;
          const res = await fetch(url);
          const data = await res.json();

          if (Array.isArray(data.records)) {
            records = records.concat(data.records);
          }
          cursor = data.cursor || null;
        } while (cursor);

        return records;
      }

      function analyzePosts(records) {
        // First, filter out any posts prior to MIN_DATE
        const filteredRecords = records.filter(rec => {
          if (rec.value.createdAt) {
            const postDate = new Date(rec.value.createdAt);
            return postDate >= MIN_DATE;
          }
          return false;
        });

        // Posts that include an image embed
        const postsWithImages = filteredRecords.filter(
          rec => rec.value.embed && rec.value.embed["$type"] === "app.bsky.embed.images"
        );
        
        // Posts with image embed that include alt text on at least one image
        const postsWithAltText = postsWithImages.filter(rec =>
          rec.value.embed.images.some(img => img.alt && img.alt.trim())
        );

        // Posts that are replies (have the 'reply' property) AND contain an image embed.
        const imageReplies = filteredRecords.filter(rec =>
          rec.value.embed && 
          rec.value.embed["$type"] === "app.bsky.embed.images" &&
          rec.value.reply
        );

        const altTextPercentage = (postsWithAltText.length / postsWithImages.length) * 100 || 0;
        let emoji = emojis[0];
        if (altTextPercentage >= 75) {
          emoji = emojis[3];
        } else if (altTextPercentage >= 50) {
          emoji = emojis[2];
        } else if (altTextPercentage >= 25) {
          emoji = emojis[1];
        }

        return {
          totalPosts: filteredRecords.length,
          postsWithImages: postsWithImages.length,
          postsWithAltText: postsWithAltText.length,
          imageReplies: imageReplies.length,
          altTextPercentage: altTextPercentage,
          emoji: emoji,
        };
      }

      // Generate an SVG half-pie chart with needle based on the alt text percentage.
      function generatePieChart(percentage) {
        // We'll create a half-circle chart (from 180¬∞ to 0¬∞)
        const width = 400, height = 250;
        const cx = width / 2, cy = height; // center at bottom middle
        const oR = 100; // outer radius
        const total = 100;
        
        // Data segments: with alt text and without alt text.
        const data = [
          { name: 'With Alt', value: percentage, color: '#00ff00' },
          { name: 'Without Alt', value: total - percentage, color: '#ff0000' }
        ];
        
        // Helper function to convert polar coordinates to cartesian.
        function polarToCartesian(cx, cy, r, angleDeg) {
          const angleRad = (angleDeg - 90) * Math.PI / 180.0;
          return {
             x: cx + (r * Math.cos(angleRad)),
             y: cy + (r * Math.sin(angleRad))
          };
        }
        
        // Helper function to describe an arc path in SVG.
        function describeArc(cx, cy, radius, startAngle, endAngle) {
          const start = polarToCartesian(cx, cy, radius, endAngle);
          const end = polarToCartesian(cx, cy, radius, startAngle);
          const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
          return [
            "M", start.x, start.y, 
            "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y
          ].join(" ");
        }
        
        // Build the paths for each segment.
        let currentAngle = 180;
        let paths = "";
        data.forEach(segment => {
          const segmentAngle = (segment.value / total) * 180;
          const startAngle = currentAngle;
          const endAngle = currentAngle - segmentAngle;
          const arcPath = describeArc(cx, cy, oR, startAngle, endAngle);
          const d = arcPath + " L " + cx + " " + cy + " Z";
          paths += `<path d="${d}" fill="${segment.color}" stroke="none"></path>`;
          currentAngle = endAngle;
        });
        
        // Draw the needle. (Needle rotates along the half circle.)
        const needleAngle = 180 - (percentage / 100) * 180;
        const needleLength = oR; // can adjust if desired
        const needleEnd = polarToCartesian(cx, cy, needleLength, needleAngle);
        let needleSVG = `<line x1="${cx}" y1="${cy}" x2="${needleEnd.x}" y2="${needleEnd.y}" stroke="#000" stroke-width="3"></line>`;
        needleSVG += `<circle cx="${cx}" cy="${cy}" r="5" fill="#000"></circle>`;
        
        return `<svg width="${width}" height="${height}">
                  ${paths}
                  ${needleSVG}
                </svg>`;
      }

      document.getElementById("search-form").addEventListener("submit", async (event) => {
        event.preventDefault();

        const username = document.getElementById("username").value.trim();
        const resultsDiv = document.getElementById("results");
        // Show the results container immediately so "Loading..." appears.
        resultsDiv.style.display = "block";
        resultsDiv.textContent = "Loading...";

        try {
          // Step 1: Resolve DID
          const did = await resolveHandleToDID(username);

          // Step 2: Fetch service endpoint from PLC directory
          const serviceEndpoint = await fetchServiceEndpoint(did);

          // Step 3: Fetch records using the service endpoint
          const records = await fetchRecordsForCollection(serviceEndpoint, did, "app.bsky.feed.post");

          // Step 4: Analyze posts (only including posts on or after 2022-11-16)
          const analysis = analyzePosts(records);

          // Determine the score message depending on image post count
          const scoreText = analysis.postsWithImages === 0 
            ? "No image posts detected! üîç" 
            : `${analysis.altTextPercentage.toFixed(2)}% ${analysis.emoji}`;

          // Generate the pie chart SVG using the alt text percentage.
          const pieChartSVG = generatePieChart(analysis.altTextPercentage);

          // Display analysis results (and pie chart) in the results card
          resultsDiv.innerHTML = `
            <p>${analysis.totalPosts} posts analyzed</p>
            <p>${analysis.postsWithImages} contain images</p>
            <p>${analysis.imageReplies} are replies with images</p>
            <p>${analysis.postsWithAltText} image posts have alt text</p>
            <h2>Score: ${scoreText}</h2>
            ${pieChartSVG}
            <a href="https://bsky.app/profile/cred.blue" target="_blank">Discover more tools: @cred.blue</a>
          `;
        } catch (error) {
          resultsDiv.textContent = `Error: ${error.message}`;
        }
      });
    </script>
  </main>

  <!-- Footer -->
  <div id="footer"></div>
  <script src="js/main.js"></script>
</body>
</html>
